-- All functions related to senator card management, buying, and positioning

-- Senator board placement and positioning
function placeSenatorBoard()
    --print('Placing senator board')
    local ClothBoard = nil
    local WineBoard = nil
    local rot = Vector(0,180,0)

    SenatorBoardWineOriginalPos = SenatorBoardWine.getPosition()
    SenatorBoardClothOriginalPos = SenatorBoardCloth.getPosition()
    SenatorBoardWineOriginalRot = SenatorBoardWine.getRotation()
    SenatorBoardClothOriginalRot = SenatorBoardCloth.getRotation()

    -- Swap logic: Move otherBoard to senatorBoard's current position
    if altWineBoard then
        --print('Swapping wine and cloth boards')
            SenatorBoardWine.setPosition(SenatorBoardClothOriginalPos)
            SenatorBoardCloth.setPosition(SenatorBoardWineOriginalPos)
            SenatorBoardWine.setRotation(SenatorBoardClothOriginalRot)
            SenatorBoardCloth.setRotation(SenatorBoardWineOriginalRot)
            SenatorBoardWine.setLock(true)
            SenatorBoardCloth.setLock(true)

    end
end

function positionBoard(obj, pos, scale, rot)
    obj.setPosition(pos)
    obj.setScale(scale)
    if rot then
        obj.setRotation(rot)
    end

    return nil
end

-- Senator board type switching (cloth/wine)
function clothOrWineBoard(obj)
    local buttonTable = obj.getButtons()
    local params = ({index = 0})

    if buttonTable[1].label == 'Cloth Display' then
        params.label = 'Wine Display'
        altWineBoard = true
    elseif buttonTable[1].label == 'Wine Display' then
        params.label = 'Cloth Display'
        altWineBoard = false
    end

    obj.editButton(params)
    return nil
end

-- Senator card restocking system
function restockSenatorBoard()
	function restockSenatorBoardCoroutine()
        --print("Restocking senator board")
		local senatorBoard = nil

        if altWineBoard then
            senatorBoard = SenatorBoardWine
        else
            senatorBoard = SenatorBoardCloth
        end

		local senatorBoardSnaps = senatorBoard.getSnapPoints()
        local existingCards = {}

        -- 1. Identify and collect all existing Senator cards in order
		for i, point in ipairs(senatorBoardSnaps) do
			local pos = senatorBoard.positionToWorld(point.position)
            local hitObj = rayCast(pos, senatorBoard)

            if hitObj and hitObj.hasTag('Senator') then
                table.insert(existingCards, hitObj)
            end
		end

        -- 2. Move existing cards to the leftmost empty slots
        for i, card in ipairs(existingCards) do
            local targetSnap = senatorBoardSnaps[i]
            local targetPos = senatorBoard.positionToWorld(targetSnap.position)

            card.setPositionSmooth(targetPos + Vector(0, 0.3, 0))
            -- Keep existing rotation
        end

        -- 3. Fill the remaining slots from the deck
        local slotsFilled = #existingCards
        local totalSlots = #senatorBoardSnaps

        if slotsFilled < totalSlots then
            for i = slotsFilled + 1, totalSlots do
                local targetSnap = senatorBoardSnaps[i]
                local targetPos = senatorBoard.positionToWorld(targetSnap.position)

                local drawDeck = nil
                if mainDeckZone then
                    for _, obj in ipairs(mainDeckZone.getObjects()) do
                        if obj.type == 'Deck' or obj.type == 'Card' then
                            drawDeck = obj
                            break
                        end
                    end
                end

                if not drawDeck then
                    --print('No draw deck found')
                    break
                end

                local params = {
                    position = targetPos + Vector(0, 0.3, 0),
                    flip = true,
                    smooth = false,
                    rotation = {0, 90, 0}
                }

                if drawDeck.type == 'Deck' then
                    local drawnCard = drawDeck.takeObject(params)
                    drawnCard.addTag("Senator")
                elseif drawDeck.type == 'Card' then
                    drawDeck.addTag("Senator")
                    drawDeck.setPosition(targetPos + Vector(0, 0.3, 0))
                    drawDeck.setRotation({0, 90, 0})
                end

                coroutine.yield(0)
            end
        end

		return 1
	end

	startLuaCoroutine(self, 'restockSenatorBoardCoroutine')
end

function findNextSenatorCard(startPos, snapTable, obj)
	for i = startPos, #snapTable, 1 do
        local pos = obj.positionToWorld(snapTable[i].position)
        local hitObj = rayCast(pos, obj)
        if hitObj then
            --print("hitobject: " .. hitObj.getName())
            if hitObj.hasTag('Senator') then
                return hitObj
            end
        end
	end

	return nil
end

-- Senator card buying system
function makeSenatorBuyButton(obj)
    obj.createButton({
        width = 400,
        height = 250,
        position = {-0.5, 0.3, -1.55},
        label = 'Buy',
        click_function = 'buySenatorCard',
        color = 'Purple'
    })

    obj.createButton({
        width = 400,
        height = 250,
        position = {0.5, 0.3, -1.55},
        label = 'Council',
        click_function = 'buyWithCouncilCard',
        color = 'Blue'
    })
end

function cardPositionFinder(clickedCard) -- returns a number 1 - 7 representing the position on the senator board
    local senatorBoard = nil

    if altWineBoard then
        senatorBoard = SenatorBoardWine
    else
        senatorBoard = SenatorBoardCloth
    end

    for i = 1, 7, 1 do
        local convertedPos = senatorBoard.positionToWorld(SENATOR_BOARD_SNAPS[i].position)
        local hitObj = rayCast(convertedPos, senatorBoard)
        --Player["Red"].pingTable(convertedPos)
        if hitObj ~= nil then
            if hitObj.guid == clickedCard.guid then
                return i
            end
        end
    end

    return nil
end

function calculateCardCost(card)
    local cardCost = {}
    local tags = card.getTags()

    --print("DEBUG: Calculating cost for card " .. (card.guid))
    if not tags or #tags == 0 then
        --print("DEBUG: Card has no tags!")
    end

    for _, tag in ipairs(tags) do
        --print("DEBUG: Found tag: " .. tag)
        if tag == 'costBrick' then
            cardCost.Brick = 1
        elseif tag == 'costFood' then
            cardCost.Food = 1
        elseif tag == 'costTool' then
            cardCost.Tool = 1
        elseif tag == 'costWine' then
            cardCost.Wine = 1
        elseif tag == 'costCloth' then
            cardCost.Cloth = 1
        end
    end

    for k,v in pairs(cardCost) do
        --print("DEBUG: Cost includes " .. k .. ": " .. v)as
    end

    return cardCost
end

function buySenatorCard(clickedCard, color, alt_click)
    --print("Buying senator card " .. clickedCard.guid .. " for player " .. color)
    local cardPosition = cardPositionFinder(clickedCard)
    --print("cardPosition: " .. cardPosition or "nil")

    local cardPrice = calculateCardCost(clickedCard)
    local hasWildCost = false
    if cardPosition == 2 or cardPosition == 3 or cardPosition == 6 then
        hasWildCost = true
    end

    if cardPosition == 4 then
        if altWineBoard then
            cardPrice.Wine = (cardPrice.Wine or 0) + 1
        else
            cardPrice.Cloth = (cardPrice.Cloth or 0) + 1
        end
    elseif cardPosition == 5 then
        cardPrice.Cloth = (cardPrice.Cloth or 0) + 1
    elseif cardPosition == 6 then
        if altWineBoard then
            cardPrice.Wine = (cardPrice.Wine or 0) + 1
            --print("DEBUG: Updated cost for Wine: " .. cardPrice.Wine)
        else
            cardPrice.Cloth = (cardPrice.Cloth or 0) + 1
            --print("DEBUG: Updated cost for Cloth: " .. cardPrice.Cloth)
        end
    elseif cardPosition == 7 then
        if altWineBoard then
            cardPrice.Cloth = (cardPrice.Cloth or 0) + 1
            cardPrice.Wine = (cardPrice.Wine or 0) + 1
        else
            cardPrice.Cloth = (cardPrice.Cloth or 0) + 2
        end
    end

    -- Scan Player Warehouse
    local warehouse = playerWarehouses[color]
    if not warehouse then
        --rint("Error: No warehouse found for color " .. color)
        return 0
    end

    local inventory = { Brick={}, Food={}, Tool={}, Wine={}, Cloth={}, Salt={} }
    local snaps = warehouse.getSnapPoints()

    for _, snap in ipairs(snaps) do
        local pos = warehouse.positionToWorld(snap.position)
        local hitObj = rayCast(pos, warehouse)
        if hitObj then
            local name = hitObj.getName()
            if inventory[name] then
                table.insert(inventory[name], hitObj)
            end
        end
    end

    -- Check Affordability & Prepare Payment
    local resourcesToPay = {}
    local saltNeeded = 0

    for good, amount in pairs(cardPrice) do
        local available = #inventory[good]

        if available >= amount then
            -- Take required amount from inventory
            for i = 1, amount do
                table.insert(resourcesToPay, inventory[good][i])
            end
        else
            -- Take all available and calculate deficit
            for i = 1, available do
                table.insert(resourcesToPay, inventory[good][i])
            end
            saltNeeded = saltNeeded + (amount - available)
        end
    end

    if saltNeeded > 0 then
        if #inventory.Salt >= saltNeeded then
            for i = 1, saltNeeded do
                table.insert(resourcesToPay, inventory.Salt[i])
            end
        else
            printToAll(Player[color].steam_name .. ' you are missing resources (and insufficient Salt) to buy this card.', color)
            Player[color].pingTable(warehouse.getPosition())
            return 0
        end
    end

    if hasWildCost then
        local usedCounts = {}
        for _, obj in ipairs(resourcesToPay) do
            local name = obj.getName()
            usedCounts[name] = (usedCounts[name] or 0) + 1
        end

        local totalInventoryCount = 0
        for _, list in pairs(inventory) do
            totalInventoryCount = totalInventoryCount + #list
        end

        local totalUsedCount = 0
        for _, count in pairs(usedCounts) do
            totalUsedCount = totalUsedCount + count
        end

        local remainingCount = totalInventoryCount - totalUsedCount

        if remainingCount == 1 then
            for name, list in pairs(inventory) do
                local total = #list
                local used = usedCounts[name] or 0
                if total - used == 1 then
                    local obj = list[used + 1]
                    table.insert(resourcesToPay, obj)
                    break
                end
            end
        else
            printToAll(Player[color].steam_name .. ' please pay 1 additional resource of your choice for the ? cost.', color)
            if playerWarehouses[color] then
                Player[color].pingTable(playerWarehouses[color].getPosition())
            end
        end
    end

    local resourcesPaid = {}
    for _, obj in ipairs(resourcesToPay) do
        local name = obj.getName()
        resourcesPaid[name] = (resourcesPaid[name] or 0) + 1
        obj.destruct()
    end

    printToAll(Player[color].steam_name .. ' has paid the following for the senator card:', color)
    for name, count in pairs(resourcesPaid) do
        printToAll(name .. ': ' .. count, color)
    end

    clickedCard.clearButtons()
    clickedCard.deal(1, color)
end

function buyWithCouncilCard(obj, color, alt_click)
    if councilFlag == false then
        printToAll(Player[color].steam_name .. ' you can only buy one card per turn with the council', color)
        return 0
    end

    -- Calculate Base Cost from Card Tags (no position cost)
    local cardPrice = calculateCardCost(obj)

    -- Scan Player Warehouse
    local warehouse = playerWarehouses[color]
    if not warehouse then
        print("Error: No warehouse found for color " .. color)
        return 0
    end

    local inventory = { Brick={}, Food={}, Tool={}, Wine={}, Cloth={}, Salt={} }
    local snaps = warehouse.getSnapPoints()

    for _, snap in ipairs(snaps) do
        local pos = warehouse.positionToWorld(snap.position)
        local hitObj = rayCast(pos, warehouse)
        if hitObj then
            local name = hitObj.getName()
            if inventory[name] then
                table.insert(inventory[name], hitObj)
            end
        end
    end

    -- Check Affordability & Prepare Payment
    local resourcesToPay = {}
    local saltNeeded = 0

    for good, amount in pairs(cardPrice) do
        local available = #inventory[good]

        if available >= amount then
            -- Take required amount from inventory
            for i = 1, amount do
                table.insert(resourcesToPay, inventory[good][i])
            end
        else
            -- Take all available and calculate deficit
            for i = 1, available do
                table.insert(resourcesToPay, inventory[good][i])
            end
            saltNeeded = saltNeeded + (amount - available)
        end
    end

    -- Check if we have enough Salt to cover the deficit
    if saltNeeded > 0 then
        if #inventory.Salt >= saltNeeded then
            for i = 1, saltNeeded do
                table.insert(resourcesToPay, inventory.Salt[i])
            end
        else
            printToAll(Player[color].steam_name .. ' you are missing resources (and insufficient Salt) to buy this card.', color)
            Player[color].pingTable(warehouse.getPosition())
            return 0
        end
    end

    -- Execute Transaction
    local resourcesPaid = {}
    for _, obj in ipairs(resourcesToPay) do
        local name = obj.getName()
        resourcesPaid[name] = (resourcesPaid[name] or 0) + 1
        obj.destruct()
    end

    printToAll(Player[color].steam_name .. ' has paid the following for the senator card:', color)
    for name, count in pairs(resourcesPaid) do
        printToAll(name .. ': ' .. count, color)
    end

    obj.clearButtons()
    obj.deal(1, color)
    councilFlag = false
end
