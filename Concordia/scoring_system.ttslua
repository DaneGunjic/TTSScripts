-- Concordia Scoring System
-- All scoring functions for different gods and game mechanics

-- Main scoring calculation function
function scoreCalc()
    if gameStarted == false then return nil end
    startLuaCoroutine(self, 'scoreCalcCO')
end

function scoreCalcCO()
    local seatedPlayers = getSeatedPlayers()
    UI.setAttribute('scoreboard', 'active', true)

    for i, playerColor in ipairs(seatedPlayers) do
        UI.setAttribute('scoreboard' .. playerColor, 'active', true)
        UI.setAttribute('scoreboard' .. playerColor, 'offsetXY', 170+(i-1)*100 .. ' -140')
        UI.setValue('name' .. playerColor, getPlayerName(playerColor))

        sellWarehouseResources(playerColor)
        takeCards(playerColor)

        local t = os.clock() + 1
        while os.clock() < t do
            coroutine.yield(0)
        end

        local playerCardTotals = countCards(playerColor)
        local playerHouseCount = checkForHouses(playerColor)
        local totalScore = 0

        -- Calculate scores for each god
        local mercuryScore = scoreMercury(playerColor, playerCardTotals, playerHouseCount)
        local marsScore = scoreMars(playerColor, playerCardTotals)
        local saturnScore = scoreSaturn(playerColor, playerCardTotals.Saturn)
        local vestaScore = scoreVesta(playerColor)
        local jupiterScore = scoreJupiter(playerColor, playerCardTotals, playerHouseCount)
        local minervaScore = scoreMinerva(playerColor, playerHouseCount, playerCardTotals)
        local venusScore = scoreVenus(playerColor, playerCardTotals)

        totalScore = totalScore + mercuryScore + marsScore + saturnScore + vestaScore + jupiterScore + minervaScore + venusScore

        -- Update UI with scores
        UI.setValue('Mercury' .. playerColor, mercuryScore)
        UI.setValue('Mars' .. playerColor, marsScore)
        UI.setValue('Saturn' .. playerColor, saturnScore)
        UI.setValue('Vesta' .. playerColor, vestaScore)
        UI.setValue('Jupiter' .. playerColor, jupiterScore)
        UI.setValue('Minerva' .. playerColor, minervaScore)
        UI.setValue('Venus' .. playerColor, venusScore)

        -- Handle Concordia bonus
        if concordiaOwner == playerColor then
            UI.setValue('Concordia' .. playerColor, 7)
            totalScore = totalScore + 7
        else
            UI.setValue('Concordia' .. playerColor, 0)
        end

        UI.setValue('total' .. playerColor, totalScore)
    end

    resetTables()
    scoreBoardToggle = 1
    return 1
end

function takeCards(color)
  local playerCards = Player[color].getHandObjects()
  local playerDiscardZone = playerDiscardTiles[color]
  local playerDiscardZonePos = playerDiscardZone.getPosition()

  for _, card in ipairs(playerCards) do
    card.setPosition(playerDiscardZonePos + Vector(0, 0.1, 0))
  end
end

-- Minerva scoring (city types)
function bestMinervaCard(color)
    local bestCard = nil
    for key, card in pairs(minervaCards) do
        if card == color then
            bestCard = key
        end
    end
    if bestCard ~= nil then
        return bestCard:lower()
    else
        return nil
    end
end

function scoreVenus(color, playerCardTable)
    local numVenus = playerCardTable.Venus or 0
    if numVenus == 0 then
        return 0
    end

    local regionsWithTwo = venusRegionCheck(color)
    local baseVP = 2 * regionsWithTwo
    if baseVP > 14 then
        baseVP = 14
    end

    return numVenus * baseVP
end

function scoreMinerva(color, houseTable, playerCardTable)
    local minervaScores = {
        Brick = 0,
        Food = 0,
        Tool = 0,
        Wine = 0,
        Cloth = 0,
    }
    local minervaVP = 0

    -- Handle Salsa expansion salt cities
    if (boolSalsa) then
        local bestMinervaCard = bestMinervaCard(color)
        if bestMinervaCard ~= nil then
            local cityToAddSaltTo = bestMinervaCard .. 'Cities'
            houseTable[cityToAddSaltTo] = houseTable[cityToAddSaltTo] + houseTable.saltCities
        end
    end

    -- Calculate Minerva scores for each resource type
    for key, card in pairs(minervaCards) do
        if card == color then
            if key == 'Brick' then
                minervaScores.Brick = minervaScores.Brick + (3 * houseTable.brickCities)
                minervaVP = minervaVP + minervaScores.Brick
                --printToAll(Player[color].steam_name .. ' got ' .. minervaScores.Brick .. ' points for brick cities.', color)
            elseif key =='Food' then
                minervaScores.Food = minervaScores.Food + (3 * houseTable.foodCities)
                minervaVP = minervaVP + minervaScores.Food
                --printToAll(Player[color].steam_name .. ' got ' .. minervaScores.Food .. ' points for food cities.', color)
            elseif key == 'Tool' then
                minervaScores.Tool = minervaScores.Tool + (3 * houseTable.toolCities)
                minervaVP = minervaVP + minervaScores.Tool
                --printToAll(Player[color].steam_name .. ' got ' .. minervaScores.Tool .. ' points for tool cities.', color)
            elseif key == 'Wine' then
                minervaScores.Wine = minervaScores.Wine + (4 * houseTable.wineCities)
                minervaVP = minervaVP + minervaScores.Wine
                --printToAll(Player[color].steam_name .. ' got ' .. minervaScores.Wine .. ' points for wine cities.', color)
            elseif key == 'Cloth'then
                minervaScores.Cloth = minervaScores.Cloth + (5 * houseTable.clothCities)
                minervaVP = minervaVP + minervaScores.Cloth
                --printToAll(Player[color].steam_name .. ' got ' .. minervaScores.Cloth .. ' points for cloth cities.', color)
            end
        end
    end

    -- Reset the table for next player
    minervaScores = {
        Brick = 0,
        Food = 0,
        Tool = 0,
        Wine = 0,
        Cloth = 0,
    }
    return minervaVP
end

-- Vesta scoring (money and goods)
function scoreVesta(color)
    --print('Scoring Vesta for ' .. color)
    local playerColor = color
    local playerSupplies = playerWarehouses[playerColor]
    local playerMoney = playerMoneyValues[playerColor] or 0
    local supplies = upCast(playerSupplies, 5, 0.1, true)
    local supplyValue = 0
    local vestaVP = 0

    for _, good in pairs(supplies) do
        for _, tag in ipairs(goodsList) do
            if good.hasTag(tag) then
                supplyValue = supplyValue + good.getGMNotes()
            end
        end
    end

    vestaVP = playerMoney + supplyValue
    return (math.floor(vestaVP/10))
end

-- Saturn scoring (regions)
function scoreSaturn(color, numSaturnCards)
	local playerRegions = regionCheck(color)
	local saturnScore = 0
	saturnScore = saturnScore + (numSaturnCards * playerRegions)
	return saturnScore
end

-- Mercury scoring (good types)
function scoreMercury(color, cardTable, houseTable)
	local numMercury = cardTable.Mercury
    --print("Mercury cards for " .. color .. ": " .. tostring(numMercury))
	local baseGoodsVP = 0
	local mercuryScore = 0
	for key, goodType in pairs(houseTable) do
		if goodType > 0 and key ~= "saltCities" then
			--print("Mercury counts " .. key .. " with " .. tostring(goodType) .. " cities")
			baseGoodsVP = baseGoodsVP + 2
		else
			--print("Mercury ignores " .. key .. " with " .. tostring(goodType) .. " cities")
		end
	end

	mercuryScore = mercuryScore + (numMercury * baseGoodsVP)

	return mercuryScore
end

-- Mars scoring (colonists)
function scoreMars(color, cardTable)
  local playerColor = color
	local numMarsCards = cardTable.Mars
  local marsVP = 4
	local playerStorage = playerWarehouses[playerColor]
	-- print(playerStorage.guid)
	local storageContents = upCast(playerStorage, 5, 0.1, true)

	local numColonists = 0
	for _, obj in pairs(storageContents) do
		if obj.hasTag(color .. 'Colonist') then
			numColonists = numColonists + 1
		end
	end

	--print('You have this many unused colonists: ' .. numColonists)
    marsVP = (marsVP + (8 -(numColonists * 2))) * numMarsCards
    -- print('the value of marsVP is ' .. marsVP)
	return marsVP
end

-- Jupiter scoring (non-brick houses)
function scoreJupiter(color, cardTable, houseTable)
    --print('Scoring Jupiter for ' .. color)
    local numJupiter = cardTable.Jupiter
    local jupiterVP = 0
    local nonBrickHouseTotal = 0

    for key, house in pairs(houseTable) do
        if key ~= 'brickCities' then
            nonBrickHouseTotal = nonBrickHouseTotal + house
        end
    end

    jupiterVP = jupiterVP + (numJupiter * nonBrickHouseTotal)
    return jupiterVP
end

-- Card counting and collection functions
function countCards(color)
    --print('Counting cards for ' .. color)
    local playerDiscardTile = playerDiscardTiles[color]
    local discardZoneObjects = upCast(playerDiscardTile, 5, 0.1, true)
    local playerDeck = nil
    local cardTotals = {
        Jupiter = 0,
        Saturn = 0,
        Mars = 0,
        Mercury = 0,
        Venus = 0
    }

    for _, obj in pairs(discardZoneObjects) do
        if obj.type == 'Deck' then
            playerDeck = obj
        else
            printToAll('No deck found', 'White')
        end
    end

    if not playerDeck then return cardTotals end

    local deckToParse = playerDeck.getObjects()
    local deckPos = playerDeck.getPosition()

    for _, card in ipairs(deckToParse) do
        local tempCard = playerDeck.takeObject({position = deckPos})

        -- Track Minerva cards
        if tempCard.hasTag('MinervaBrick') then
            minervaCards.Brick = color
        elseif tempCard.hasTag('MinervaFood') then
            minervaCards.Food = color
        elseif tempCard.hasTag('MinervaTool') then
            minervaCards.Tool = color
        elseif tempCard.hasTag('MinervaWine') then
            minervaCards.Wine = color
        elseif tempCard.hasTag('MinervaCloth') then
            minervaCards.Cloth = color
        elseif tempCard.hasTag('Concordia') then
            concordiaOwner = color
        end

        -- Count god cards
        for _, tag in ipairs(cardTags) do
            if tempCard.hasTag(tag) then
                --print(tag)
                cardTotals[tag] = cardTotals[tag] + 1
            end
        end
    end

    return cardTotals
end

function collectCards(color)
    --print('Collecting cards for ' .. color)
    local playerDiscardZone = playerDiscardTiles[color]
    local playerCards = upCast(playerDiscardZone, 5, 0.1, true)
    local playerDiscardZonePos = playerDiscardZone.getPosition()

    for _, card in ipairs(playerCards) do
        card.setPosition(playerDiscardZonePos + Vector(0, 0.1, 0))
    end
end

-- House counting functions
function checkForHouses(color)
    --print('Checking for houses for ' .. color)
    local playerHouses = {
        brickCities = 0,
        clothCities = 0,
        wineCities = 0,
        toolCities = 0,
        foodCities = 0,
        saltCities = 0,
    }

    local cityTiles = getCityTiles()
    for _, city in pairs(cityTiles) do
        --print("Checking city tile: " .. city.getName() .. " (" .. city.guid .. ")")
        local hitObjs = upCast(city, 5, 0.1, true)
        for _, house in pairs(hitObjs) do
            if house.getGMNotes() == color then
                --print("Found house for " .. color .. " in city")
                updateHouseTypes(city, playerHouses)
            end
        end
    end
    return playerHouses
end

function updateHouseTypes(obj, tbl)
    if obj.hasTag('Brick') then
        tbl.brickCities = tbl.brickCities + 1
    elseif obj.hasTag('Cloth') then
        tbl.clothCities = tbl.clothCities + 1
    elseif obj.hasTag('Tool') then
        tbl.toolCities = tbl.toolCities + 1
    elseif obj.hasTag('Food') then
        tbl.foodCities = tbl.foodCities + 1
    elseif obj.hasTag('Wine') then
        tbl.wineCities = tbl.wineCities + 1
    elseif obj.hasTag('Salt') then
        tbl.saltCities = tbl.saltCities + 1
    end
end

function getCityTiles()
	local cityTiles = {}
	cityTiles = getObjectsWithAllTags({"city_tile"})
	return cityTiles
end

-- Region checking for Saturn scoring
function regionCheck(color)
	local result = 0

    if MainBoard.getStateId() == 1 then
        result = regionLoop(BritanniaRegions, stdBagB, color)
    elseif MainBoard.getStateId() == 2 then
        result = regionLoop(HispaniaRegions, stdBagA, color)
    elseif MainBoard.getStateId() == 3 then
        result = regionLoop(ItaliaRegions, stdBagA, color)
    elseif MainBoard.getStateId() == 4 then
        result = regionLoop(ByzantiumRegions, stdBagASalsa, color)
    elseif MainBoard.getStateId() == 5 then
        result = regionLoop(ImperiumRegions, stdBagA, color)
    elseif MainBoard.getStateId() == 6 then
        result = regionLoop(corsicaRegions, stdBagA, color)
    elseif MainBoard.getStateId() == 7 then
        result = regionLoop(GaliaRegions, stdBagA, color)
    elseif MainBoard.getStateId() == 8 then
        result = regionLoop(GermaniaRegions, stdBagA, color)
    elseif MainBoard.getStateId() == 9 then
        result = regionLoop(CretaRegions, stdBagA, color)
    elseif MainBoard.getStateId() == 10 then
        result = regionLoop(AegyptusRegions, stdBagA, color)
    elseif MainBoard.getStateId() == 11 then
        result = regionLoop(IONIVMRegions, stdBagA, color)
    elseif MainBoard.getStateId() == 12 then
        result = regionLoop(CYPRUSRegions, stdBagA, color)
    elseif MainBoard.getStateId() == 13 then
        result = regionLoop(BALEARICARegions, stdBagA, color)
    elseif MainBoard.getStateId() == 14 then
        result = regionLoop(HELLASRegions, stdBagA, color)
    end
    return result
end

function venusRegionCheck(color)
    local result = 0

    if MainBoard.getStateId() == 1 then
        result = regionLoopVenus(BritanniaRegions, stdBagB, color)
    elseif MainBoard.getStateId() == 2 then
        result = regionLoopVenus(HispaniaRegions, stdBagA, color)
    elseif MainBoard.getStateId() == 3 then
        result = regionLoopVenus(ItaliaRegions, stdBagA, color)
    elseif MainBoard.getStateId() == 4 then
        result = regionLoopVenus(ByzantiumRegions, stdBagASalsa, color)
    elseif MainBoard.getStateId() == 5 then
        result = regionLoopVenus(ImperiumRegions, stdBagA, color)
    elseif MainBoard.getStateId() == 6 then
        result = regionLoopVenus(corsicaRegions, stdBagA, color)
    elseif MainBoard.getStateId() == 7 then
        result = regionLoopVenus(GaliaRegions, stdBagA, color)
    elseif MainBoard.getStateId() == 8 then
        result = regionLoopVenus(GermaniaRegions, stdBagA, color)
    elseif MainBoard.getStateId() == 9 then
        result = regionLoopVenus(CretaRegions, stdBagA, color)
    elseif MainBoard.getStateId() == 10 then
        result = regionLoopVenus(AegyptusRegions, stdBagA, color)
    elseif MainBoard.getStateId() == 11 then
        result = regionLoopVenus(IONIVMRegions, stdBagA, color)
    elseif MainBoard.getStateId() == 12 then
        result = regionLoopVenus(CYPRUSRegions, stdBagA, color)
    elseif MainBoard.getStateId() == 13 then
        result = regionLoopVenus(BALEARICARegions, stdBagA, color)
    elseif MainBoard.getStateId() == 14 then
        result = regionLoopVenus(HELLASRegions, stdBagA, color)
    end
    return result
end

function sellWarehouseResources(color)
    local warehouseObj = playerWarehouses[color]
    if warehouseObj == nil then
        --printToAll(Player[color].steam_name .. ' had no warehouse to sell from', color)
        return
    end

    local goodsSold = {}
    local totalValue = 0

    local objectsInWarehouse = upCast(warehouseObj, 5, 0.1, true)

    for _, item in pairs(objectsInWarehouse) do
        local itemName = item.getName()
        local isResource = false
        for _, good in ipairs(goodsList) do
            if good == itemName then
                isResource = true
                break
            end
        end

        if isResource and itemName ~= "Salt" then
            local val = item.getGMNotes()
            local itemValue = tonumber(val) or 0
            if itemValue == 0 then
                itemValue = 1
            end

            if goodsSold[itemName] then
                goodsSold[itemName] = goodsSold[itemName] + 1
            else
                goodsSold[itemName] = 1
            end

            totalValue = totalValue + itemValue
            item.destruct()
        end
    end

    local message
    if totalValue > 0 then
        local goodsSummary = ""
        local first = true
        for key, value in pairs(goodsSold) do
            local part = key .. " x" .. tostring(value)
            if first then
                goodsSummary = part
                first = false
            else
                goodsSummary = goodsSummary .. ", " .. part
            end
        end
        message = Player[color].steam_name .. ' sold ' .. goodsSummary .. ' for ' .. totalValue .. ' sestertii'
        addMoney(color, totalValue)
    else
        message = Player[color].steam_name .. ' had no resources to sell'
    end

    printToAll(message, color)
end

-- Reset function for scoring tables
function resetTables()
    minervaCards = {
        Brick = '',
        Food = '',
        Tool = '',
        Wine = '',
        Cloth = '',
    }
    concordiaOwner = ''
    return nil
end

-- UI functions for scoreboard
function createScoreButton()
    local buttonHolder = getObjectFromGUID('4ee1f2')
    if buttonHolder then
        buttonHolder.createButton({
            position = {-20, 12, 0},
            label = 'Calculate\nScores',
            click_function = 'scoreCalc',
            width = 1500,
            height = 1000,
            font_size = 300,
            rotation = {0, 270, 0},
            color = 'Purple'
        })
    end
    return 0
end

function toggleScoreBoard()
    local seatedPlayers = getSeatedPlayers()
    if scoreBoardToggle == 0 then
        UI.setAttribute('scoreboard', 'active', true)
        for i, playerColor in ipairs(seatedPlayers) do
            UI.setAttribute('scoreboard' .. playerColor, 'active', true)
        end
        scoreBoardToggle = 1
    elseif scoreBoardToggle == 1 then
        UI.setAttribute('scoreboard', 'active', false)
        for i, playerColor in ipairs(seatedPlayers) do
            UI.setAttribute('scoreboard' .. playerColor, 'active', false)
        end
        scoreBoardToggle = 0
    end
    return nil
end
