function rayCast(StartPosition, obj)
    local hit = Physics.cast({
        origin = StartPosition,
        type = 3,
        size = {0.6, 0.6, 0.6},
        direction = {0, -1, 0},
        max_distance = 0.1,
        debug = false
    })

    for _, hitInfo in ipairs(hit) do
        --print(hitInfo.hit_object.guid)
        -- Never detect the object we are casting over, and never detect the game table
        if hitInfo.hit_object ~= obj and hitInfo.hit_object ~= GameTableObject then
            return hitInfo.hit_object
        end
    end

    return nil
end

function upCast(obj, dist, offset, multi)
    local dist = dist or 5
    local offset = offset or 2
    local multi = multi or false

    local pos = obj.getPosition()
    pos.y = pos.y + offset

    local hit = Physics.cast({
        origin = pos,
        direction = {0, 1, 0},
        type = 3,
        size = obj.getBounds().size,
        max_distance = dist,
        debug = false
    })

    local hitObjects = {}
    for _, hitInfo in ipairs(hit) do
        local isMoneyCounter = false
        if playerMoneyCounters then
            for _, counter in pairs(playerMoneyCounters) do
                if hitInfo.hit_object == counter then
                    isMoneyCounter = true
                    break
                end
            end
        end

        if hitInfo.hit_object ~= obj and not isMoneyCounter then
            table.insert(hitObjects, hitInfo.hit_object)
        end
    end

    if multi then
        return hitObjects
    else
        return hitObjects[1]
    end
end

-- Table utility functions
function tableParser(key, tableToSearch)
    for _, thing in ipairs(tableToSearch) do
        if key == thing then
            return true
        end
    end
    return false
end

function getTableTotal(tbl)
    local total = 0
    for _, thing in pairs(tbl) do
        total = total + thing
    end
    return total
end

function tableChecker(checkMe, findMe)
    for _, thing in ipairs(checkMe) do
        if thing == findMe then
            return true
        end
    end
    return false
end

function TableConcat(t1, t2)
    for i = 1, #t2 do
        t1[#t1 + 1] = t2[i]
    end
    return t1
end

-- Array manipulation functions
function shuffleArray(array)
    local counter = #array * 10
	local maxIndex = #array
    while counter > 1 do
        local index = math.random(maxIndex)
		local index2 = math.random(maxIndex)
        swap(array, index, index2)
        counter = counter - 1
    end
	return array
end

function shuffleList(list)
    for i = #list, 2, -1 do
        local j = math.random(i)
        list[i], list[j] = list[j], list[i]
    end
    return list
end

function findFirst(who)
	local counter = 1
	local maxC = #stdTOTALISGERMANS
	while counter <= maxC do
		if(stdTOTALISGERMANS[counter] == who)
		then
			return counter
		end
		counter = counter + 1
	end
end

function TakeMove(targetObjectBag, params)
	return targetObjectBag.takeObject(params)
end

function createArrayForNCards(start, number)
    local array = {}
    for i = start, start + number - 1 do
        table.insert(array, i)
    end
    return array
end

function swap(array, index1, index2)
    array[index1], array[index2] = array[index2], array[index1]
end

function debugArray(array)
    local output = "Array contents: "
    for i, value in ipairs(array) do
        output = output .. tostring(value) .. " "
    end
    print(output)
end

-- Object finding utilities
function checkForDeckOrCard(objGuid)
    local objZone = getObjectFromGUID(objGuid)
    if not objZone then return nil end

    local zoneContents = objZone.getObjects()
    for _, thing in ipairs(zoneContents) do
        if thing.type == 'Deck' or thing.type == 'Card' then
            return thing
        end
    end
    return nil
end

function AddRemoveResource(color, add, resource)
    local warehouse = playerWarehouses[color]
    if not warehouse then return end

    local warehouseSnaps = warehouse.getSnapPoints()

    if add then
        -- Find the correct bag
        local bag = nil
        if resource == "Brick" then bag = supplyBags.BrickTop or supplyBags.BrickBottom
        elseif resource == "Food" then bag = supplyBags.FoodTop or supplyBags.FoodBottom
        elseif resource == "Tool" then bag = supplyBags.ToolTop or supplyBags.ToolBottom
        elseif resource == "Wine" then bag = supplyBags.WineTop or supplyBags.WineBottom
        elseif resource == "Cloth" then bag = supplyBags.ClothTop or supplyBags.ClothBottom
        elseif resource == "Salt" then bag = saltBags.SaltTop or saltBags.SaltBottom
        end

        if not bag then
            print("Error: Could not find bag for resource " .. tostring(resource))
            return false
        end

        -- Find empty spot
        for _, snap in pairs(warehouseSnaps) do
            local oPosition = warehouse.positionToWorld(snap.position) + Vector(0, 0.5, 0)
            local blocker = rayCast(oPosition, warehouse)

            if not blocker then
                --print("Position/SnapPoint: " .. tostring(oPosition))
                bag.takeObject({
                    position = oPosition,
                    rotation = {0, 180, 0},
                    smooth = false
                })
                printToAll(Player[color].steam_name .. ' added ' .. resource, color)
                return true
            end
        end
        printToAll(Player[color].steam_name .. ' warehouse is full!', color)
        return false

    else
        -- Remove resource
        for _, snap in pairs(warehouseSnaps) do
            local oPosition = warehouse.positionToWorld(snap.position) + Vector(0, 0.5, 0)
            local blocker = rayCast(oPosition, warehouse)

            if blocker and blocker.getName() == resource then
                blocker.destruct()
                printToAll(Player[color].steam_name .. ' removed ' .. resource, color)
                return true
            end
        end
        printToAll(Player[color].steam_name .. ' does not have ' .. resource .. ' to remove!', color)
        return false
    end
end

function getValue(subject)
    if subject == brickA or subject == brickB or subject == brickC or subject == brickD then
        return 1
    elseif subject == foodA or subject == foodB or subject == foodC or subject == foodD then
        return 2
    elseif subject == toolA or subject == toolB or subject == toolC or subject == toolD then
        return 3
    elseif subject == wineA or subject == wineB or subject == wineC or subject == wineD then
        return 4
    elseif subject == clothA or subject == clothB or subject == clothC or subject == clothD then
        return 5
    else
        return 0
    end
end

function whatIsBest(objA, objB)
	local valueA = getValue(objA)
	print("valueA: " .. valueA)
	local valueB = getValue(objB)
	print("valueB: " .. valueB)
	if(valueA == valueB or valueA > valueB)
	then
		return objA
	else
		return objB
	end
end
