-- Concordia Game Setup
-- All functions related to board setup, player setup, and deck management

CLOCKWISE_ORDER = { "White", "Red", "Green", "Yellow", "Blue", "Brown" }

function getSortedSeatedPlayers()
    local seated = getSeatedPlayers()
    local sorted = {}
    for _, color in ipairs(CLOCKWISE_ORDER) do
        for _, p in ipairs(seated) do
            if p == color then
                table.insert(sorted, color)
                break
            end
        end
    end
    return sorted
end

function StartGame()
    --print("Starting game...")
    numberOfPlayers = #getSeatedPlayers()
    DestroySetupButtons()
    startLuaCoroutine(Global, 'runInitialSetup')
end

-- Cleanup function for setup buttons
function DestroySetupButtons()
    --print("Destroying remaining setup buttons...")
    hideExpansionButtons()
    hideMapButtons()
    hideSetupButtons()
end

function SelectBoardBritannia() setBoard(1) end
function SelectBoardHispania() setBoard(2) end
function SelectBoardItalia() setBoard(3) end
function SelectBoardByzantivm() setBoard(4) end
function SelectBoardImperivm() setBoard(5) end
function SelectBoardCorsica() setBoard(6) end
function SelectBoardGallia() setBoard(7) end
function SelectBoardGermania() setBoard(8) end
function SelectBoardCreta() setBoard(9) end
function SelectBoardAegyptus() setBoard(10) end
function SelectBoardIonivm() setBoard(11) end
function SelectBoardCyprvs() setBoard(12) end
function SelectBoardBalearica() setBoard(13) end
function SelectBoardHellas() setBoard(14) end

function setBoard(stateId)
    --print('[game_setup] INFO: setBoard called with stateId = ' .. stateId .. ' selectedMap = ' .. MainBoard.getStateId())
    if MainBoard and MainBoard.getStateId() == stateId then
        return
    end

    local mapDef = MapDefinitions[stateId]

    selectedMap = stateId
    if MainBoard and MainBoard.setState then
        --print('[game_setup] INFO: Setting board to stateId = ' .. stateId)
        MainBoard = MainBoard.setState(stateId)

        if mapDef then
             local targetRotation = mapDef.rotation or 0
             local currentRot = MainBoard.getRotation()
             MainBoard.setRotation({currentRot.x, targetRotation, currentRot.z})

             if mapDef.scale then
                 MainBoard.setScale(mapDef.scale)
             end
        else
             local currentRot = MainBoard.getRotation()
             MainBoard.setRotation({currentRot.x, 0, currentRot.z})
        end

        MainBoard.locked = true
        MainBoard.interactable = false

        --print('[game_setup] INFO: Board set to stateId = ' .. stateId)
    else
        print('[game_setup] WARN: MainBoard not available or not stateful')
    end
end

-- Main setup coroutine
function runInitialSetup()
    --print("Run initial setup")
	gameStarted = true
	shufflestuff()

    -- Ensure Turns order is consistent with our logic
    local sortedPlayers = getSortedSeatedPlayers()
    Turns.order = sortedPlayers

	if boolSalsa then
        makeSaltBagButtons(saltBags)
        addSalt()
        for _, color in ipairs(sortedPlayers) do
            AddRemoveResource(color, true, "Salt")
        end
    else
        for _, color in ipairs(sortedPlayers) do
            AddRemoveResource(color, true, "Food")
        end
	end

    if forum then
        setupForumTiles()
    end

    local mapId = MainBoard.getStateId()
    local mapDef = MapDefinitions[mapId]

    if mapDef then
        -- Place cities
        if mapDef.cities then
            for _, cityInfo in ipairs(mapDef.cities) do
                PlaceCities(cityInfo.data, cityInfo.bag)
            end
        end

        -- Concatenate tables
        if mapDef.concats then
            for _, concat in ipairs(mapDef.concats) do
                TableConcat(concat.target, concat.source)
            end
        end

        -- Parse regions
            if mapDef.parse then
                parseRegions(mapDef.parse.bag, mapDef.parse.regions, mapDef.parse.tiles, mapDef.parse.ignoreRegions)
            end

        -- Custom setup
        if mapDef.customSetup then
            mapDef.customSetup()
        end
    else
        broadcastToAll("Error: No configuration found for map state ID " .. tostring(mapId), {1,0,0})
    end

	MainBoard.interactable = false

    randomFirstPlayer()
    Wait.time(startingMoney, 1)
    setMainDeck()
    placeSenatorBoard()

	return true
end

function swapDecks(zone1, zone2)
    local deck1 = getDeckFromZone(zone1)
    local deck2 = getDeckFromZone(zone2)

    if deck1 and deck2 then
        local pos1 = deck1.getPosition()
        local pos2 = deck2.getPosition()
        deck1.setPosition(pos2)
        deck2.setPosition(pos1)
    end
end

-- Money and starting setup
function startingMoney()
    --print("Starting money")
    local turnOrder = Turns.order
    local startPlayer = Turns.turn_color
    local startIndex = 1

    -- Find index of starting player
    for i, color in ipairs(turnOrder) do
        if color == startPlayer then
            startIndex = i
            --print("starting index: " .. startIndex .. " for color " .. color)
            break
        end
    end

    local currentMoney = 5
    local playerCount = #turnOrder
    local numberOfTeams = math.max(1, math.floor(playerCount / 2))

    for i = 0, playerCount - 1 do
        local index = ((startIndex + i - 1) % playerCount) + 1
        local color = turnOrder[index]

        if teamsEnabled then
            addMoney(color, 5 + (i % numberOfTeams))
        else
            addMoney(color, currentMoney)
            currentMoney = currentMoney + 1
        end
    end
end

function randomFirstPlayer()
    --print("Random first player")
    local seatedPlayers = getSeatedPlayers()
    local r = math.random(1, #seatedPlayers)
    --broadcastToAll("The starting player is: " .. seatedPlayers[r])
    Turns.turn_color = seatedPlayers[r]
end

function addSalt()
    stdBagA[1] = saltA
    stdBagB[1] = saltB
    stdBagC[1] = saltC
    stdBagD[1] = saltD

    stdBagASalsa[1] = saltA
    stdBagBSalsa[1] = saltB
    stdBagCSalsa[1] = saltC
    stdBagDSalsa[1] = saltD
end

function setupForumTiles()
    local blueBag = ForumBlueBag
    local greenBag = ForumGreenBag
    if not blueBag or not greenBag then
        return
    end

    blueBag.shuffle()
    greenBag.shuffle()

    local seatedPlayers = getSeatedPlayers()

    for _, color in ipairs(seatedPlayers) do
        local warehouse = playerWarehouses[color]
        local basePos
        if warehouse then
            local wPos = warehouse.getPosition()
            basePos = {wPos.x, wPos.y, wPos.z}
        else
            local bPos = blueBag.getPosition()
            basePos = {bPos.x, bPos.y, bPos.z}
        end

        for i = 1, 2 do
            local contents = blueBag.getObjects()
            if not contents or #contents == 0 then
                break
            end
            local entry = contents[1]
            local offsetX = (i - 0.5) * 1.5
            local params = {}
            params.guid = entry.guid
            params.position = {basePos[1] + offsetX, basePos[2] + 2, basePos[3]}
            params.rotation = {0, 180, 0}
            params.smooth = false
            blueBag.takeObject(params)
        end
    end

    local remaining = blueBag.getObjects()
    if remaining and #remaining > 0 then
        local gPos = greenBag.getPosition()
        for _, entry in ipairs(remaining) do
            local obj = blueBag.takeObject({guid = entry.guid, position = gPos, smooth = false})
            greenBag.putObject(obj)
        end
    end
end

-- Germany specific setup
function placeGermanThings()
    if selectedMap == 8 then -- Germania
        for i, pos in ipairs(posGermanyExtraLoot) do
            local tokenBag = getObjectFromGUID(genericTokenBAGGUID)
            if tokenBag then
                tokenBag.takeObject({position = pos})
            end
        end
    end
end

function PlaceCities(targetArray, cityBits)
    local brickTiles = {brickA, brickB, brickC, brickD}
    local clothTiles = {clothA, clothB, clothC, clothD}
    local foodTiles = {foodA, foodB, foodC, foodD}
    local toolTiles = {toolA, toolB, toolC, toolD}
    local wineTiles = {wineA, wineB, wineC, wineD}
    local saltTiles = {saltA, saltB, saltC, saltD}

	if targetArray ~= nil then
		local count = 1
		local numMaxArray = #targetArray
		shuffleArray(cityBits)
		shuffleArray(cityBits)
		shuffleArray(cityBits)
		while count <= numMaxArray do
			local obj_parameters = {}
			obj_parameters.type = 'Custom_Model'
			obj_parameters.position = targetArray[count]
			obj_parameters.rotation = {0.00, 180, 0.00}

			obj = spawnObject(obj_parameters)
			obj.setLock(true)
			custom = {}
			custom.mesh = 'http://pastebin.com/raw/CnZMEjc3'
			custom.diffuse = cityBits[count]
			custom.material = 1
			obj.setCustomObject(custom)

            -- local textPos = obj.getPosition() + Vector(0, 0.5, 0)
            -- local textObj = spawnObject({
            --     type = "3DText",
            --     position = textPos,
            --     rotation = {90, 0, 0},
            --     sound = false,
            -- })
            -- textObj.setValue(tostring(count))
            -- textObj.setLock(true)

            obj.addTag('city_tile')
            if cityBits[count] == tableChecker(brickTiles, cityBits[count]) then
                obj.addTag('brick')
            elseif cityBits[count] == tableChecker(clothTiles, cityBits[count]) then
                obj.addTag('cloth')
            elseif cityBits[count] == tableChecker(foodTiles, cityBits[count]) then
                obj.addTag('food')
            elseif cityBits[count] == tableChecker(toolTiles, cityBits[count]) then
                obj.addTag('tool')
            elseif cityBits[count] == tableChecker(wineTiles, cityBits[count]) then
                obj.addTag('wine')
            elseif cityBits[count] == tableChecker(saltTiles, cityBits[count]) then
                obj.addTag('salt')
            end

			cityBits[count] = obj
			count = count + 1
			debugCounter = debugCounter+1
		end
	end
end

function drawRegionBest(lootSwitcher, pos)
    local bag = nil
    if lootSwitcher == 1 then
        bag = BrickTokenBag
    elseif lootSwitcher == 2 then
        bag = FoodTokenBag
    elseif lootSwitcher == 3 then
        bag = ToolTokenBag
    elseif lootSwitcher == 4 then
        bag = WineTokenBag
    elseif lootSwitcher == 5 then
        bag = ClothTokenBag
    end

    local params = {}
	params.position = pos
	params.rotation = {0.00, 180.00, 0.00}
    params.smooth = false
	bag.takeObject(params)
end

function removeOneGuy(lootSwitcher)
    if lootSwitcher == 1 then
        table.remove(stdTOTALISGERMANS, findFirst(brickA))
    elseif lootSwitcher == 2 then
        table.remove(stdTOTALISGERMANS, findFirst(foodA))
    elseif lootSwitcher == 3 then
        table.remove(stdTOTALISGERMANS, findFirst(toolA))
    elseif lootSwitcher == 4 then
        table.remove(stdTOTALISGERMANS, findFirst(wineA))
    elseif lootSwitcher == 5 then
        table.remove(stdTOTALISGERMANS, findFirst(clothA))
    end
end

function shufflestuff()
    if teamsEnabled then
        Personality1Deck_Teams.shuffle()
        Personality2Deck_Teams.shuffle()
        Personality3Deck_Teams.shuffle()
        Personality4Deck_Teams.shuffle()
        Personality5Deck_Teams.shuffle()
    else
        Personality1Deck_NoTeams.shuffle()
        Personality2Deck_NoTeams.shuffle()
        Personality3Deck_NoTeams.shuffle()
        Personality4Deck_NoTeams.shuffle()
        Personality5Deck_NoTeams.shuffle()
    end
end

function stuffDeck(target, source, count)
    for _ = 1, count do
        source.takeObject({
            position = target.getPosition(),
            rotation = {0, 90, 180},
            smooth = false
        })
    end
end

function setMainDeck()
    local p1, p2, p3, p4, p5
    if teamsEnabled then
        p1 = Personality1Deck_Teams
        p2 = Personality2Deck_Teams
        p3 = Personality3Deck_Teams
        p4 = Personality4Deck_Teams
        p5 = Personality5Deck_Teams
    else
        p1 = Personality1Deck_NoTeams
        p2 = Personality2Deck_NoTeams
        p3 = Personality3Deck_NoTeams
        p4 = Personality4Deck_NoTeams
        p5 = Personality5Deck_NoTeams
    end

    --need to accomodate for venus count of 32 cards in deck
	p1.setPosition(mainDeckLocation)
    p1.setRotation({0, 90, 180})

    --print("venusMode is off, setting up main deck for " .. numberOfPlayers .. " players")
    stuffDeck(p1, p2, #p2.getObjects())
    if(numberOfPlayers > 2 ) then
        stuffDeck(p1,p3, #p3.getObjects())
        if(numberOfPlayers > 3 ) then
            stuffDeck(p1,p4, #p4.getObjects())
            if(numberOfPlayers > 4 ) then
                stuffDeck(p1,p5, #p5.getObjects())
            end
        end
    end

    Wait.time(restockSenatorBoard, 1)
end

function parseRegions(CityTokens, RegionsAndCities, regionArray, ignoreRegions)
	if CityTokens ~= nil then
        createSnapPointsFromTokens(MainBoard, regionArray)
		local bestLoot = brickA
		local CurrentRegion = 1
		local Regions = #RegionsAndCities

		while CurrentRegion <= Regions do
            if not (ignoreRegions and ignoreRegions[CurrentRegion]) then

			local CitiesCount = 1
			local CitiesInRegion = #RegionsAndCities[CurrentRegion]
			bestLoot = brickA
			while CitiesCount <= CitiesInRegion do
				local CityNumber = RegionsAndCities[CurrentRegion][CitiesCount]
				local obj_parameters = CityTokens[CityNumber].getCustomObject()

				bestLoot = whatIsBest(bestLoot, obj_parameters.diffuse)
				CitiesCount = CitiesCount + 1
			end
			drawRegionBest(getValue(bestLoot), regionArray[CurrentRegion])
			removeOneGuy(getValue(bestLoot))
            end

            CurrentRegion = CurrentRegion + 1
		end
	end
end

-- Market setup for Forum expansion
function RollMarketFORUM(targetDeck, marketZone1GUID, marketZone2GUID, marketZone3GUID, marketZone4GUID,
    marketZone1Pos, marketZone2Pos, marketZone3Pos, marketZone4Pos)

    if lockDoubleTrouble then
        local marketZone1 = getObjectFromGUID(marketZone1GUID).getObjects()
        local marketZone2 = getObjectFromGUID(marketZone2GUID).getObjects()
        local marketZone3 = getObjectFromGUID(marketZone3GUID).getObjects()
        local marketZone4 = getObjectFromGUID(marketZone4GUID).getObjects()

        local globalFailedMovement = false
        local push = true

        -- Market shifting logic for Forum expansion
        for i, token in ipairs(marketZone1) do
            if token.getName() ~= 'FORVM' then
                push = false
            end
        end

        if push then
            globalFailedMovement = true
        else
            push = true
        end

        for i, token in ipairs(marketZone2) do
            if token.getName() ~= 'FORVM' then
                push = false
                if globalFailedMovement then
                    moveTo(token, marketZone1Pos)
                end
            end
        end

        -- Continue similar logic for other market zones...
    end
end

function checkLastCardDeckInzone(locationZone)
    local zone = getObjectFromGUID(locationZone)
    if zone then
        local objects = zone.getObjects()
        for _, obj in pairs(objects) do
            if obj.type == 'Deck' or obj.type == 'Card' then
                return obj
            end
        end
    end
    return nil
end

function createSnapPointsFromTokens(board, tokenList)
    if not board or not tokenList then return end

    local snapPoints = board.getSnapPoints() or {}
    local currentRot = board.getRotation()
    local targetWorldY = 180
    local localY = targetWorldY - currentRot.y

    for _, pos in ipairs(tokenList) do
        local worldPos = {x=pos[1], y=pos[2], z=pos[3]}
        local localPos = board.positionToLocal(worldPos)

        table.insert(snapPoints, {
            position = localPos,
            rotation = {0, localY, 0},
            rotation_snap = true
        })
    end

    board.setSnapPoints(snapPoints)
end
