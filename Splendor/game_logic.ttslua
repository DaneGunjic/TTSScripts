-- Splendor Game Logic
-- Handles turn management, win conditions, and core game flow

-- Game state variables
local currentPlayerIndex = 1
local gameStarted = false
local gameEnded = false
local playerCount = 0
local playersOrder = {}

-- Initialize game logic
function initializeGameLogic()
    currentPlayerIndex = 1
    gameStarted = false
    gameEnded = false
end

-- Set player turn
function setPlayerTurn(player)
    if getPlayers then
        local players = getPlayers()
        for i, p in pairs(players) do
            if p:lower() == player:lower() then
                currentPlayerIndex = i
                break
            end
        end
    end
end

-- Get current player
function getCurrentPlayer()
    if getPlayers then
        local players = getPlayers()
        return players[currentPlayerIndex]
    end
    return nil
end

-- Next turn
function nextTurn()
    if gameEnded then
        return
    end
    
    local players = {}
    if getPlayers then
        players = getPlayers()
    end
    
    if #players == 0 then
        return
    end
    
    currentPlayerIndex = currentPlayerIndex + 1
    if currentPlayerIndex > #players then
        currentPlayerIndex = 1
    end
    
    local currentPlayer = players[currentPlayerIndex]
    
    -- Check for nobles
    if checkPeopleStatus then
        checkPeopleStatus(currentPlayer)
    end
    
    -- Check win conditions
    checkWinConditions()
    
    -- Update UI
    if updateTable then
        updateTable()
    end
    
    -- Broadcast turn change
    local MESSAGES = {
        TURN_CHANGE = "It's %s's turn"
    }
    broadcastToAll(string.format(MESSAGES.TURN_CHANGE, currentPlayer), {1, 1, 1})
end

-- Check win conditions
function checkWinConditions()
    if gameEnded then
        return
    end
    
    local players = {}
    if getPlayers then
        players = getPlayers()
    end
    
    local winners = {}
    local WINNING_POINTS = 15
    
    -- Check if any player has 15+ points
    for _, player in pairs(players) do
        local points = 0
        if getPlayerPoints then
            points = getPlayerPoints(player)
        end
        
        if points >= WINNING_POINTS then
            table.insert(winners, {player = player, points = points})
        end
    end
    
    if #winners > 0 then
        endGame(winners)
    end
end

-- End game
function endGame(winners)
    gameEnded = true
    
    if #winners == 1 then
        local MESSAGES = {
            WINNER = "%s wins with %d points!",
            GAME_OVER = "Game Over!"
        }
        broadcastToAll(string.format(MESSAGES.WINNER, winners[1].player, winners[1].points), {0, 1, 0})
        broadcastToAll(MESSAGES.GAME_OVER, {1, 1, 1})
    else
        -- Handle tie
        local tieWinners = getWinnersWhenDraw(winners)
        if #tieWinners == 1 then
            local MESSAGES = {
                TIE_WINNER = "%s wins the tiebreaker with %d points and %d cards!",
                GAME_OVER = "Game Over!"
            }
            broadcastToAll(string.format(MESSAGES.TIE_WINNER, tieWinners[1].player, tieWinners[1].points, tieWinners[1].cards), {0, 1, 0})
            broadcastToAll(MESSAGES.GAME_OVER, {1, 1, 1})
        else
            local MESSAGES = {
                TIE = "It's a tie!",
                GAME_OVER = "Game Over!"
            }
            broadcastToAll(MESSAGES.TIE, {1, 1, 0})
            broadcastToAll(MESSAGES.GAME_OVER, {1, 1, 1})
        end
    end
end

-- Get winners when there's a draw (tiebreaker by card count)
function getWinnersWhenDraw(winners)
    local maxCards = 0
    local tieWinners = {}
    
    -- Find maximum card count among winners
    for _, winner in pairs(winners) do
        local cardCount = 0
        if getPlayerCardCount then
            cardCount = getPlayerCardCount(winner.player)
        end
        winner.cards = cardCount
        
        if cardCount > maxCards then
            maxCards = cardCount
        end
    end
    
    -- Get all winners with maximum card count
    for _, winner in pairs(winners) do
        if winner.cards == maxCards then
            table.insert(tieWinners, winner)
        end
    end
    
    return tieWinners
end

-- Validate token hand size
function validTokenHandSize(player)
    local MAX_TOKENS = 10
    local tokenCount = 0
    
    if countCurrentPlayerTokens then
        tokenCount = countCurrentPlayerTokens(player)
    end
    
    return tokenCount <= MAX_TOKENS
end

-- Check if play is valid
function isValidPlay(player, action, data)
    if gameEnded then
        return false, "Game has ended"
    end
    
    local currentPlayer = getCurrentPlayer()
    if player:lower() ~= currentPlayer:lower() then
        return false, "It's not your turn"
    end
    
    if action == "take_gems" then
        -- Validate gem taking
        if bankGemZone then
            local selectedGems = data.gems or {}
            local count = #selectedGems
            
            if count == 0 then
                return false, "No gems selected"
            elseif count == 1 then
                return false, "Must take at least 2 gems"
            elseif count == 2 then
                -- Taking 2 of same color
                if selectedGems[1] ~= selectedGems[2] then
                    return false, "When taking 2 gems, they must be the same color"
                end
                
                local zone = bankGemZone(selectedGems[1])
                if getZoneGemCount(zone) < 4 then
                    return false, "Need at least 4 gems of this color to take 2"
                end
            elseif count == 3 then
                -- Taking 3 different colors
                local colors = {}
                for _, gem in pairs(selectedGems) do
                    if colors[gem] then
                        return false, "When taking 3 gems, they must be different colors"
                    end
                    colors[gem] = true
                    
                    local zone = bankGemZone(gem)
                    if getZoneGemCount(zone) == 0 then
                        return false, "Not enough gems of color: " .. gem
                    end
                end
            else
                return false, "Can only take 2 or 3 gems"
            end
            
            -- Check if player will exceed token limit
            local currentTokens = 0
            if countCurrentPlayerTokens then
                currentTokens = countCurrentPlayerTokens(player)
            end
            
            if currentTokens + count > 10 then
                return false, "Would exceed maximum token limit (10)"
            end
        end
    elseif action == "buy_card" then
        -- Validate card purchase
        local card = data.card
        if not card then
            return false, "No card specified"
        end
        
        if parseCard then
            local cardData = parseCard(card)
            if not checkPayment(player, cardData.cost) then
                return false, "Insufficient gems to buy this card"
            end
        end
    elseif action == "reserve_card" then
        -- Validate card reservation
        local card = data.card
        if not card then
            return false, "No card specified"
        end
        
        -- Check if player has space for reserved cards (max 3)
        local reservedCount = 0
        if getPlayerReservedCount then
            reservedCount = getPlayerReservedCount(player)
        end
        
        if reservedCount >= 3 then
            return false, "Cannot reserve more than 3 cards"
        end
    end
    
    return true, "Valid play"
end

-- Start game
function startGame()
    gameStarted = true
    gameEnded = false
    currentPlayerIndex = 1
    
    local MESSAGES = {
        GAME_START = "Game started!",
        FIRST_TURN = "It's %s's turn"
    }
    
    broadcastToAll(MESSAGES.GAME_START, {0, 1, 0})
    
    local currentPlayer = getCurrentPlayer()
    if currentPlayer then
        broadcastToAll(string.format(MESSAGES.FIRST_TURN, currentPlayer), {1, 1, 1})
    end
end

-- Check if game has started
function hasGameStarted()
    return gameStarted
end

-- Check if game has ended
function hasGameEnded()
    return gameEnded
end

-- Get current player index
function getCurrentPlayerIndex()
    return currentPlayerIndex
end

-- Set current player index
function setCurrentPlayerIndex(index)
    currentPlayerIndex = index
end

-- Get player count
function getPlayerCount()
    return playerCount
end

-- Set player count
function setPlayerCount(count)
    playerCount = count
end

-- Warn all players
function warnAll(message)
    local COLORS = {
        WARNING = {1, 0.4, 0, 1}
    }
    broadcastToAll(message, COLORS.WARNING)
end

-- Process turn action
function processTurnAction(player, action, data)
    local isValid, message = isValidPlay(player, action, data)
    
    if not isValid then
        warnAll(message)
        return false
    end
    
    -- Process the action
    if action == "take_gems" then
        if takeMultiColoredGems then
            takeMultiColoredGems(data.gems, player)
        end
    elseif action == "buy_card" then
        if parseCard then
            local cardData = parseCard(data.card)
            payCost(player, cardData.cost)
            playCard(data.card, player)
        end
    elseif action == "reserve_card" then
        if reserveCard then
            reserveCard(data.card, player)
        end
    end
    
    -- End turn
    nextTurn()
    return true
end