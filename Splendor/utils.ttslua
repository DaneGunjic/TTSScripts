-- Splendor Utility Functions
-- Helper functions and utilities used throughout the game

-- Check if a table contains a specific value
function contains(tab, val)
    for index, value in pairs(tab) do
        if value == val then
            return true
        end
    end
    return false
end

-- Get the index of a value in a table
function getIndex(tab, val)
    for k, v in pairs(tab) do
        if (v == val) then
            return k
        end
    end
end

-- Get key for a given value in a table
function getKeyForValue(table, value)
    for k, v in pairs(table) do
        if v == value then
            return k
        end
    end
end

-- Object type checking functions
function isToken(object)
    return object.name == 'Custom_Model'
end

function isCard(object)
    return object.name == 'Card'
end

function isDeck(object)
    return object.name == 'Deck'
end

-- Position calculation functions
function cardPosition(xPos, zPos)
    return {xPos, 3, zPos}
end

function personParams(xPoz)
    return {position = {xPoz, 4, 4.4}, flip = true, rotation = {0, 180, 0}}
end

function playerCardPosition(player, zone, cardIndex)
    local pos = zone.getPosition()
    local offset
    if (cardIndex == nil) then
        offset = -4 + #zone.getObjects()
    else
        offset = -5 + cardIndex
    end
    if player == 'Red' then
        return {pos.x, pos.y, pos.z - offset}
    elseif player == 'Blue' then
        return {pos.x, pos.y, pos.z + offset}
    elseif player == 'Pink' then
        return {pos.x + offset, pos.y, pos.z}
    elseif player == 'Green' then
        return {pos.x - offset, pos.y, pos.z}
    else
        broadcastToAll('An error occurred', {r = 1, g = 0.4, b = 0, a = 1})
    end
end

-- Zone utility functions
function isZoneEmpty(zone)
    return zone.getObjects() == nil or #zone.getObjects() == 0
end

function getZoneGemCount(zone)
    if isZoneEmpty(zone) then
        return 0
    else
        return #zone.getObjects()
    end
end

-- Token management utilities
function getTopTokensFromZone(zone, count)
    local topTokens = {}
    if count == 0 or isZoneEmpty(zone) then
        return topTokens
    end
    local yPositions = {}
    for k, token in pairs(zone.getObjects()) do
        table.insert(yPositions, token.getPosition().y)
    end
    table.sort(yPositions)
    local skipCount = #zone.getObjects() - count
    local minY = yPositions[1 + skipCount]
    for k, token in pairs(zone.getObjects()) do
        if minY <= token.getPosition().y then
            table.insert(topTokens, token)
        end
    end
    return topTokens
end

function getTopTokenFromZone(zone)
    return getTopTokensFromZone(zone, 1)[1]
end

-- Parsing functions
function parseCostString(costString)
    local cost = {}
    for capture in string.gmatch(costString, '%d+%a+') do
        local value = costString.match(capture, '%d+')
        local colour = costString.match(capture, '%a+')
        cost[colour] = tonumber(value)
    end
    return cost
end

function parseCard(object)
    local substrings = {}
    for s in string.gmatch(object.getName(), '%S+') do
        table.insert(substrings, s)
    end
    return {
        id = substrings[1],
        score = tonumber(substrings[2]),
        bonus = substrings[3],
        cost = parseCostString(substrings[4])
    }
end

function parsePerson(object)
    local substrings = {}
    for s in string.gmatch(object.getName(), '%S+') do
        table.insert(substrings, s)
    end
    return {
        score = 3, -- PERSON_SCORE constant
        cost = parseCostString(substrings[1])
    }
end

-- Table serialization utility
function serializeTable(val, name, skipnewlines, depth)
    skipnewlines = skipnewlines or false
    depth = depth or 0

    local tmp = string.rep(" ", depth)

    if name then
        if type(name) == "number" then
            tmp = tmp
        else
            tmp = tmp .. name .. " = "
        end
    end

    if type(val) == "table" then
        tmp = tmp .. "{" .. (not skipnewlines and "\n" or "")

        for k, v in pairs(val) do
            tmp = tmp .. serializeTable(v, k, skipnewlines, depth + 1) .. "," .. (not skipnewlines and "\n" or "")
        end

        tmp = tmp .. string.rep(" ", depth) .. "}"
    elseif type(val) == "number" then
        tmp = tmp .. tostring(val)
    elseif type(val) == "string" then
        tmp = tmp .. string.format("%q", val)
    elseif type(val) == "boolean" then
        tmp = tmp .. (val and "true" or "false")
    else
        tmp = tmp .. "\"[inserializeable datatype:" .. type(val) .. "]\""    end

    return tmp
end

-- Dummy function for buttons
function dummy()
end