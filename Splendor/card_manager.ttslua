function getPlayerGems(player)
    local playerData = getPlayer(player)
    return {
        red = playerData.rGemCount,
        white = playerData.wGemCount,
        green = playerData.gGemCount,
        black = playerData.bGemCount,
        blue = playerData.uGemCount,
        gold = playerData.jGemCount
    }
end

function payCost(player, cost)
    local playerGems = getPlayerGems(player)
    local goldNeeded = 0
    for colour, amount in pairs(cost) do
        local gemColour = COST_COLOUR_NAMES[colour]
        local playerGemCount = playerGems[gemColour]
        local shortfall = amount - playerGemCount
        if shortfall > 0 then
            goldNeeded = goldNeeded + shortfall
        end
    end
    if playerGems.gold < goldNeeded then
        return false
    end
    for colour, amount in pairs(cost) do
        local gemColour = COST_COLOUR_NAMES[colour]
        local playerGemCount = playerGems[gemColour]
        local gemsToTake = math.min(amount, playerGemCount)
        if gemsToTake > 0 then
            moveTokens(playerGemZone(player, gemColour), bankGemZone(gemColour), gemsToTake)
            changeGemCount(player, gemColour, -gemsToTake)
        end
    end
    if goldNeeded > 0 then
        moveTokens(playerGemZone(player, GOLD_NAME), bankGemZone(GOLD_NAME), goldNeeded)
        changeGemCount(player, GOLD_NAME, -goldNeeded)
    end
    return true
end

function playCard(object, player, dealNext)
    print("playCard")
    local card = parseCard(object)
    local cost = considerDiscount(player, card.cost)
    local payment = checkPayment(player, cost)
    if payment.valid then
        payCost(player, payment.cost, payment.goldCost)
        local cardZone = playerZones[player:lower()].cards[COST_COLOUR_NAMES[card.bonus]]
        local position = playerCardPosition(player, cardZone)
        local rotation = {x = 0, y = PLAYER_Y_ROTATION[player], z = 0}
        local objectJSON = object.getJSON()
          if dealNext then
            object.setRotationSmooth(rotation, false, false)
            object.setPositionSmooth(position, false, false)
            dealNewCardInPlaceOf(object)
          elseif not dealNext then
            object.destruct()
            spawnObjectJSON({json = objectJSON, position = position, rotation = rotation})
          end
        awardPoints(player, card.score)
        addCardCount(player, card.bonus)
        nextTurn()
        return true
    else
        Player[player].broadcast('You dont have enough tokens to play this card', CHAT_INFO_COLOR)
    end
    
    return false
end

function reserveDeckCallback(object_spawned, params)
    object_spawned.interactable = true
    object_spawned.deal(1, params.player)
end

function reserveCard(player, object, dealNext)
    if #Player[player].getHandObjects() >= MAX_HAND_SIZE then
      if soundToggle == 'talk' then
        dingSound.AssetBundle.playTriggerEffect(8)
        Player[player].broadcast('You can only have up to 3 cards reserved at a time', CHAT_INFO_COLOR)
      else
        Player[player].broadcast('You can only have up to 3 cards reserved at a time', CHAT_INFO_COLOR)
      end
    else
        if isDeck(object) then
            object.takeObject({position = {0, 0, 0}, callback = "reserveDeckCallback", callback_owner = Global, params = {player = player}})
            refreshDeckTooltip(object)
        elseif isCard(object) then
            object.interactable = true
            if object.getButtons() != nil then
			      object.removeButton(0)
            end
            object.deal(1, player)
        end
        if getZoneGemCount(goldGemZone) > 0 then
            moveToken(goldGemZone, playerGemZone(player, GOLD_NAME))
            changeGemCount(player, 'gold', 1 )
        end
        if dealNext then
            dealNewCardInPlaceOf(object)
        end
        nextTurn()
    end
end