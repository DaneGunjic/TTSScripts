-- Constants
SPLAY_TYPE = {
	STACK = 0,
	LEFT = 1,
	RIGHT = 2,
	UP = 3,
	ASLANT = 4
}

SPLAY_DIR_STR = {
	[SPLAY_TYPE.STACK] = "None",
	[SPLAY_TYPE.LEFT] = "Left",
	[SPLAY_TYPE.RIGHT] = "Right",
	[SPLAY_TYPE.UP] = "Up",
	[SPLAY_TYPE.ASLANT] = "Aslant"
}

-- Splay state storage
splay_state = {
	White = { Blue = "None", Yellow = "None", Purple = "None", Red = "None", Green = "None" },
	Red = { Blue = "None", Yellow = "None", Purple = "None", Red = "None", Green = "None" },
	Blue = { Blue = "None", Yellow = "None", Purple = "None", Red = "None", Green = "None" },
	Green = { Blue = "None", Yellow = "None", Purple = "None", Red = "None", Green = "None" }
}

function splay_cards(paramtable)
	local splay_type_int = paramtable.newsplay
	local zone = getObjectFromGUID(paramtable.zone)
	local player_color = player_by_zone(paramtable.zone)

	if not player_color then
		print("Error: Could not determine player from zone " .. tostring(paramtable.zone))
		return
	end

	local dir = SPLAY_DIR_STR[splay_type_int] or "None"

	local current_splay_state = get_splay_state(player_color, paramtable.color)
	if current_splay_state ~= dir then
		broadcastToAll(Player[player_color].steam_name .. " splayed " .. paramtable.color .. " " .. dir)
	end

	set_splay_state(player_color, paramtable.color, dir)

	if splay_type_int == SPLAY_TYPE.STACK then
		splay_stacked(zone, paramtable.color, comparisonY)
	else
		anchored_splay(zone, player_color, paramtable.color, dir)
	end

	updateSplayButtonLabel(player_color, paramtable.color, splay_type_int)
	--UpdateGameState() -- Uncomment if needed globally, but usually handled by specific functions
end

function splay_stacked(zone, color, sort_function, save_previous)
	local cards = zone.getObjects()
	local pos = nil
	local y_increase = 0.1
	local cards_table = {}
	for i, n in pairs(cards) do cards_table[i] = n end

	table.sort(cards_table, sort_function)

	for k, deck in ipairs(cards_table) do
		local deck_from_guid = getObjectFromGUID(deck.guid)
		if deck.type == "Card" and getCardColor(deck.getDescription()) == color then
			if pos == nil then pos = deck_from_guid.getPosition() end
			pos.y = pos.y + y_increase
			deck.setPosition(pos)
			deck.setLock(false)
		end
		-- Note: Deck handling logic was commented out in original, assuming it's not needed for simple stack
		y_increase = y_increase + 0.1
	end

	UpdateGameState()
end

function splay_right(zone, color, wait_time, save_previous)
	local player = player_by_zone(zone.getGUID())
	if player then
		anchored_splay(zone, player, color, "Right")
	end
end

function splay_up(zone, color, wait_time, save_previous)
	local player = player_by_zone(zone.getGUID())
	if player then
		anchored_splay(zone, player, color, "Up")
	end
end

function splay_left(zone, color, wait_time, save_previous)
	local player = player_by_zone(zone.getGUID())
	if player then
		anchored_splay(zone, player, color, "Left")
	end
end

function player_by_zone(zone_guid)
	for p, g in pairs(zone_zones) do
		if g == zone_guid then return p end
	end
	return nil
end

function getColorCards(player, color)
	local zone = getObjectFromGUID(zone_zones[player])
	if not zone then return {} end
	
	local cards = zone.getObjects()
	local list = {}
	for i, obj in pairs(cards) do
		if obj.type == "Card" and getCardColor(obj.getDescription()) == color then
			table.insert(list, obj)
		end
	end
	return list
end

function getBottomAnchor(player, color, state)
	local list = {}

	for i, obj in pairs(getColorCards(player, color)) do
		if obj ~= nil then
			local success, pos = pcall(function() return obj.getPosition() end)
			if success then
				table.insert(list, { obj = obj, pos = pos })
			end
		end
	end

	if #list == 0 then
		local zone = getObjectFromGUID(zone_zones[player])
		if not zone then return nil, false end

		for i, obj in pairs(zone.getObjects()) do
			if obj.type == "Deck" then
				local deck_cards = obj.getObjects()
				if deck_cards[1] ~= nil and getCardColor(deck_cards[1].description) == color then
					return obj, true
				end
			end
		end

		return nil, false
	end

	-- Always find the card with the lowest Y coordinate (min Y) - lowest height
	local min_y = 100000
	local anchor = nil
	for i, e in pairs(list) do
		if e.pos.y < min_y then
			min_y = e.pos.y; anchor = e.obj
		end
	end
	return anchor, false
end

function anchored_splay(zone, player, color, dir)
	local anchor, anchor_is_deck = getBottomAnchor(player, color, dir)

	if anchor == nil then return end

	-- Determine direction multipliers
	local dir_x, dir_z = 0, 0
	if dir == "Left" then dir_x = -1
	elseif dir == "Right" then dir_x = 1
	elseif dir == "Up" then dir_z = 1
	elseif dir == "Aslant" then dir_x = 1; dir_z = 1
	end

	-- Flip direction for top players (Blue/Green)
	if player == "Blue" or player == "Green" then
		dir_x = -dir_x
		dir_z = -dir_z
	end

	local stepX = SPLAY_SHIFT_X * dir_x
	local stepZ = SPLAY_SHIFT_Z * dir_z

	if anchor_is_deck then
		local extracted_cards = {}
		local deck_pos = anchor.getPosition()
		local deck_rot = anchor.getRotation()
		local deck_cards = anchor.getObjects()

		for i, card_data in ipairs(deck_cards) do
			local offset_x = stepX * (i - 1)
			local offset_z = stepZ * (i - 1)
			local target_pos = deck_pos + Vector(offset_x, (i - 1) * 0.05, offset_z)

			if i < #deck_cards then
				local spawned_card = anchor.takeObject({
					guid = card_data.guid,
					position = target_pos,
					rotation = deck_rot,
					smooth = false,
				})
				if spawned_card then
					spawned_card.setLock(true)
					table.insert(extracted_cards, spawned_card)
				end
			else
				-- Last card: the deck object is destroyed, find the remaining card by GUID
				local last_card = getObjectFromGUID(card_data.guid)
				if last_card then
					last_card.setPosition(target_pos)
					last_card.setRotation(deck_rot)
					last_card.setLock(true)
					table.insert(extracted_cards, last_card)
				else
					print("Error: Could not find last card " .. card_data.guid)
				end
			end
		end
	else
		-- Anchor is a single card
		local ax = anchor.getPosition().x
		local az = anchor.getPosition().z
		local ay = anchor.getPosition().y
		local zone_pos = zone.getPosition()
		
		local cards = getColorCards(player, color)
		local sorted = {}

		for i, obj in pairs(cards) do
			table.insert(sorted, obj)
		end

		table.sort(sorted, comparisonY)

		for i, obj in pairs(sorted) do
			if obj ~= nil then
				local success, pos = pcall(function() return obj.getPosition() end)
				
				if success then
					-- Base position on anchor
					pos.x = ax + ((i - 1) * stepX)
					pos.z = az + ((i - 1) * stepZ)

					-- The first card (anchor) keeps its height. Subsequent cards are stacked higher.
					if i > 1 then
						pos.y = ay + ((i - 1) * 0.05)
					end

					pcall(function() obj.setPosition(pos) end)
					pcall(function() obj.setLock(true) end)
				end
			end
		end
	end

	UpdateGameState()
end

function shift_selected_color_left(player)
	shift_selected_color(player, -SPLAY_SHIFT_X, 0)
end

function shift_selected_color_right(player)
	shift_selected_color(player, SPLAY_SHIFT_X, 0)
end

function shift_selected_color_up(player)
	shift_selected_color(player, 0, SPLAY_SHIFT_Z)
end

function shift_selected_color_down(player)
	shift_selected_color(player, 0, -SPLAY_SHIFT_Z)
end

selected_color_per_player = {}

function select_splay_color(player, color)
	selected_color_per_player[player] = color
end

function shift_selected_color(player, dx, dz)
	local color = selected_color_per_player[player]
	if color == nil then return end

	local zone_guid = zone_zones[player]
	local zone = getObjectFromGUID(zone_guid)
	if zone and zone.getPosition().z > 0 then
		dx = -dx
		dz = -dz
	end

	local anchor, anchor_is_deck = getBottomAnchor(player, color, get_splay_state(player, color))
	if anchor == nil then return end
	
	for i, obj in pairs(getColorCards(player, color)) do
		local pos = obj.getPosition()
		pos.x = pos.x + dx
		pos.z = pos.z + dz
		obj.setPositionSmooth(pos, false, true)
		obj.setLock(true)
	end
end

function get_splay_state(player, color)
	if not splay_state[player] then return "None" end
	return splay_state[player][color] or "None"
end

function set_splay_state(player, color, state)
	if splay_state[player] == nil then
		splay_state[player] = { Blue = "None", Yellow = "None", Purple = "None", Red = "None", Green = "None" }
	end
	splay_state[player][color] = state
end

function get_card_count(zone, color)
	local count = 0
	local cards = zone.getObjects()
	for i, deck in pairs(cards) do
		if deck.type == 'Card' then
			if color == getCardColor(deck.getDescription()) then
				count = count + 1
			end
		end
	end

	return count
end

function comparisonRight(a, b)
	return a.getPosition().x < b.getPosition().x
end

function comparisonUp(a, b)
	return a.getPosition().z < b.getPosition().z
end

function comparisonY(a, b)
	return a.getPosition().y < b.getPosition().y
end

function updateSplayButtonLabel(player, card_color, splay_type_int)
	local table_obj = getObjectFromGUID("4ee1f2")
	if table_obj == nil then return end

	local splay_text = "Not Splayed"
	if splay_type_int == SPLAY_TYPE.LEFT then
		splay_text = "Splayed Left"
	elseif splay_type_int == SPLAY_TYPE.RIGHT then
		splay_text = "Splayed Right"
	elseif splay_type_int == SPLAY_TYPE.UP then
		splay_text = "Splayed Up"
	elseif splay_type_int == SPLAY_TYPE.ASLANT then
		splay_text = "Splayed Aslant"
	end

	local target_tooltip = player .. ":Reset Splay"

	local buttons = table_obj.getButtons()
	if buttons then
		for _, btn in ipairs(buttons) do
			if btn.click_function == "no_splay_" .. card_color and btn.tooltip == target_tooltip then
				table_obj.editButton({
					index = btn.index,
					label = card_color .. "\n" .. splay_text
				})
				break
			end
		end
	end
end

function comparisonLeft(a, b)
	return a.getPosition().x > b.getPosition().x
end

function click_func(obj, color, alt_click)
	return
end
