function splay_cards(paramtable)
  local splay_type = paramtable.newsplay
  local zone = getObjectFromGUID(paramtable.zone)
  local player = player_by_zone(paramtable.zone)

  --print("new splay_type: " .. paramtable.newsplay .. " old splay_type: " .. paramtable.oldsplay)

  if paramtable.newsplay == 0 then --splay stack
    set_splay_state(player, paramtable.color, "None")
    if paramtable.oldsplay == 1 then --was left
      splay_stacked(zone, paramtable.color, comparisonLeft)
    elseif paramtable.oldsplay == 2 then --was right
      splay_stacked(zone, paramtable.color, comparisonRight)
    elseif paramtable.oldsplay == 3 then --was up
      splay_stacked(zone, paramtable.color, comparisonUp)
    end
  elseif paramtable.newsplay == 1 then --splay left
    --print("splay left")
    set_splay_state(player, paramtable.color, "Left")
    anchored_splay(zone, player, paramtable.color, "Left")
  elseif paramtable.newsplay == 2 then --splay right
    --print("splay right")
    set_splay_state(player, paramtable.color, "Right")
    anchored_splay(zone, player, paramtable.color, "Right")
  elseif paramtable.newsplay == 3 then --splay up
    set_splay_state(player, paramtable.color, "Up")
    anchored_splay(zone, player, paramtable.color, "Up")
  end

  updateSplayButtonLabel(player, paramtable.color, paramtable.newsplay)
end

function splay_stacked(zone, color, sort_function, save_previous)
  --print("splay_stacked " .. color)
  local cards = zone.getObjects()
  local pos = nil
  local y_increase = 0.1
  local a = {}
  for i, n in pairs(cards) do a[i] = n end

  table.sort(a, sort_function)
  for k, deck in ipairs(a) do
    local deck_from_guid = getObjectFromGUID(deck.guid)
    if deck.type == "Deck" then
      local deck_cards = deck_from_guid.getObjects()
      for j, v in pairs(deck_cards) do
        if color == getCardColor(v.description) then
          if pos == nil then pos = deck_from_guid.getPosition() end
          pos.y = pos.y + y_increase/3
          deck_from_guid.takeObject({position=pos})
        end
      end
    elseif deck.type == "Card" and getCardColor(deck.getDescription()) == color then
      if pos == nil then pos = deck_from_guid.getPosition() end
      pos.y = pos.y + y_increase
      deck.setPositionSmooth(pos, false, true)
      deck.setLock(false)
    end
    y_increase = y_increase + 0.1
  end
end

function splay_right(zone, color, wait_time, save_previous)
  local player = player_by_zone(zone.getGUID())
  anchored_splay(zone, player, color, "Right")
end

function splay_up(zone, color, wait_time, save_previous)
  local player = player_by_zone(zone.getGUID())
  anchored_splay(zone, player, color, "Up")
end

function splay_left(zone, color, wait_time, save_previous)
  local player = player_by_zone(zone.getGUID())
  anchored_splay(zone, player, color, "Left")
end

function player_by_zone(zone_guid)
  for p, g in pairs(zone_zones) do
    if g == zone_guid then return p end
  end
  return nil
end

function getColorCards(player, color)
  local zone = getObjectFromGUID(zone_zones[player])
  local cards = zone.getObjects()
  local list = {}
  for i, obj in pairs(cards) do
    if obj.type == "Card" and getCardColor(obj.getDescription()) == color then
      table.insert(list, obj)
    end
  end
  return list
end

function getBottomAnchor(player, color, state)
  local list = {}

  for i, obj in pairs(getColorCards(player, color)) do
    --print("Found " .. obj.getName() .. " (" .. color .. ")")
    table.insert(list, {obj=obj, pos=obj.getPosition()})
  end

  if #list == 0 then
    local zone = getObjectFromGUID(zone_zones[player])
    for i, obj in pairs(zone.getObjects()) do
      if obj.type == "Deck" then
        local deck_cards = obj.getObjects()
        if deck_cards[1] ~= nil and getCardColor(deck_cards[1].description) == color then
          --print("Found a deck." .. " (" .. color .. ") as anchor")
          return obj, true
        end
      end
    end

    return nil, false
  end

  -- Always find the card with the lowest Y coordinate (min Y) - lowest height
  local min_y = 100000
  local anchor = nil
  for i, e in pairs(list) do
    if e.pos.y < min_y then min_y = e.pos.y; anchor = e.obj end
  end
  return anchor, false
end

function anchored_splay(zone, player, color, dir)
  --print("anchored_splay " .. dir .. " for " .. color)

  local state = dir
  local anchor, anchor_is_deck = getBottomAnchor(player, color, state)

  if anchor == nil then return end

  if anchor_is_deck then
		local extracted_cards = {}
    --print("Anchor is a deck")

    local deck_pos = anchor.getPosition()
    local deck_rot = anchor.getRotation()
    local deck_cards = anchor.getObjects()
    local matching_guids = {}
    local bottom_card_guid = nil

    -- Find bottom-most matching card to be the new anchor
    for i = 1, #deck_cards, 1 do
      if getCardColor(deck_cards[i].description) == color then
        bottom_card_guid = deck_cards[i].guid
        --print("[1] Found " .. deck_cards[i].name .. " (" .. color .. ") as bottom card")
        break
      end
    end

    -- Collect all matching GUIDs
    for i, c in ipairs(deck_cards) do
       if getCardColor(c.description) == color then
         table.insert(matching_guids, c.guid)
       end
    end

		for i, card_data in ipairs(deck_cards) do
			--print(card_data.guid)
			local OffsetX = 0
			local OffsetZ = 0

			if dir == "Left" then
				OffsetX = -SPLAY_SHIFT_X * (i - 1)
			elseif dir == "Right" then
				OffsetX = SPLAY_SHIFT_X * (i - 1)
			elseif dir == "Up" then
				OffsetZ = SPLAY_SHIFT_Z * (i - 1)
			end

			local target_pos = deck_pos + Vector(OffsetX, (i - 1) * 0.05, OffsetZ)

			if i < #deck_cards then
				local spawned_card = anchor.takeObject({
					guid = card_data.guid,
					position = target_pos,
					rotation = deck_rot,
					smooth = false,
				})
				spawned_card.setLock(true)
				table.insert(extracted_cards, spawned_card)
			else
				-- Last card: the deck object is destroyed, find the remaining card by GUID
				local last_card = getObjectFromGUID(card_data.guid)
				if last_card then
					last_card.setPosition(target_pos)
					last_card.setRotation(deck_rot)
					last_card.setLock(true)
					table.insert(extracted_cards, last_card)
				else
					print("Error: Could not find last card " .. card_data.guid)
				end
			end
			--print("Pulled a card")
		end
  else
    --print("Anchor is not a deck")
    --print("Anchor name: " .. anchor.getName())
    local ax = anchor.getPosition().x
    local az = anchor.getPosition().z
    local flipped = zone.getPosition().z > 0
    local stepX = SPLAY_SHIFT_X
    local stepZ = SPLAY_SHIFT_Z

    if flipped then
      stepX = -stepX
      stepZ = -stepZ
    end

    local cards = getColorCards(player, color)
    local sorted = {}

    for i, obj in pairs(cards) do
      table.insert(sorted, obj)
    end

    table.sort(sorted, comparisonY)

    for i, obj in pairs(sorted) do
        local pos = obj.getPosition()
        if dir == "Left" then
          pos.z = az
          pos.x = ax + ((i-1) * -stepX)
        elseif dir == "Right" then
          pos.z = az
          pos.x = ax + ((i-1) * stepX)
        elseif dir == "Up" then
          pos.x = ax
          pos.z = az + ((i-1) * stepZ)
        end
        obj.setPosition(pos)
        obj.setLock(true)
    end
  end
end

function shift_selected_color_left(player)
  shift_selected_color(player, -SPLAY_SHIFT_X, 0)
end

function shift_selected_color_right(player)
  shift_selected_color(player, SPLAY_SHIFT_X, 0)
end

function shift_selected_color_up(player)
  shift_selected_color(player, 0, SPLAY_SHIFT_Z)
end

function shift_selected_color_down(player)
  shift_selected_color(player, 0, -SPLAY_SHIFT_Z)
end

selected_color_per_player = {}

function select_splay_color(player, color)
  selected_color_per_player[player] = color
end

function shift_selected_color(player, dx, dz)
  local color = selected_color_per_player[player]
  if color == nil then return end

  local zone_guid = zone_zones[player]
  local zone = getObjectFromGUID(zone_guid)
  if zone and zone.getPosition().z > 0 then
    dx = -dx
    dz = -dz
  end

  local anchor, anchor_is_deck = getBottomAnchor(player, color, get_splay_state(player, color))
  if anchor == nil then return end
  --print(anchor.getName())
  local ax = anchor.getPosition().x
  local az = anchor.getPosition().z
  for i, obj in pairs(getColorCards(player, color)) do
    local pos = obj.getPosition()
    pos.x = pos.x + dx
    pos.z = pos.z + dz
    obj.setPositionSmooth(pos, false, true)
    obj.setLock(true)
  end
end

-- Splay state storage and accessors
splay_state = {
  White = { Blue="None", Yellow="None", Purple="None", Red="None", Green="None" },
  Red =   { Blue="None", Yellow="None", Purple="None", Red="None", Green="None" },
  Blue =  { Blue="None", Yellow="None", Purple="None", Red="None", Green="None" },
  Green = { Blue="None", Yellow="None", Purple="None", Red="None", Green="None" }
}

function get_splay_state(player, color)
  local ps = splay_state[player]
  if ps == nil then return "None" end
  return ps[color] or "None"
end

function set_splay_state(player, color, state)
  --print("Set splay state for " .. player .. " to " .. state .. " for " .. color)
  if splay_state[player] == nil then
    splay_state[player] = { Blue="None", Yellow="None", Purple="None", Red="None", Green="None" }
  end
  splay_state[player][color] = state
end

function get_card_count(zone, color)
  local count = 0
  local cards = zone.getObjects()
  for i, deck in pairs(cards) do
    if deck.type == 'Card' then
      if color == getCardColor(deck.getDescription()) then
        count = count + 1
      end
    end
  end

  return count
end

function comparisonRight(a, b)
  return a.getPosition().x < b.getPosition().x
end

function comparisonUp(a, b)
  return a.getPosition().z < b.getPosition().z
end

function comparisonY(a, b)
  return a.getPosition().y < b.getPosition().y
end

function updateSplayButtonLabel(player, card_color, splay_type_int)
  local table_obj = getObjectFromGUID("4ee1f2")
  if table_obj == nil then return end

  local splay_text = "Not Splayed"
  if splay_type_int == 1 then splay_text = "Splayed Left"
  elseif splay_type_int == 2 then splay_text = "Splayed Right"
  elseif splay_type_int == 3 then splay_text = "Splayed Up"
  end

  local target_tooltip = player .. ":Reset Splay"

  local buttons = table_obj.getButtons()
  if buttons then
    for _, btn in ipairs(buttons) do
      if btn.click_function == "no_splay_" .. card_color and btn.tooltip == target_tooltip then
        table_obj.editButton({
          index = btn.index,
          label = card_color .. "\n" .. splay_text
        })
        break
      end
    end
  end
end

function comparisonLeft(a, b)
  return a.getPosition().x > b.getPosition().x
end

function click_func(obj, color, alt_click)
  return
end
