ReturnHome = {}

ReturnHome.defaults = {
  spaceBetweenPawns = nil,
  offset = nil
}

function ReturnHome.init(defaultSpaceBetweenPawns, defaultOffset)
  ReturnHome.defaults.spaceBetweenPawns = defaultSpaceBetweenPawns or 0.8
  ReturnHome.defaults.offset = defaultOffset or vector(0, 3, 0)
end

function ReturnHome.returnHome(homes)
  local mainBoard = getObjectFromGUID(boardId)
  for i, homeInfo in pairs(homes) do
    local homeBoard = getObjectFromGUID(homeInfo.boardId)
    
    -- Stop here if the player board does not exist
    if homeBoard != nil then
      local unlockedPawns = {}
      if mainBoard then
        unlockedPawns = ReturnHome.getPawnsOnBoard(mainBoard, homeInfo.pawnIds)
      end
      local pawnWidth = ReturnHome.getAverageWidthOfPawns(unlockedPawns)
      
      local spaceBetweenPawns = homeInfo.spaceBetweenPawns or ReturnHome.defaults.spaceBetweenPawns
      local offset = homeInfo.offset or ReturnHome.defaults.offset
      local pawnArrangementWidth = ReturnHome.getPawnArrangementWidth(unlockedPawns, pawnWidth, spaceBetweenPawns)
      
      -- Arrange the unlocked pawns
      for k, pawn in pairs(unlockedPawns) do
        -- Orient the pawn relative to the board
        local pawnRotation = homeBoard.getRotation()
        if not homeInfo.pawnRotation == nil then
          -- Use the provided rotation
          pawnRotation = pawnRotation + homeInfo.pawnRotation
        elseif pawn.getBoundsNormalized().size.x > pawn.getBoundsNormalized().size.z then
          -- Rotate by 90 degrees so that non-square things are taller than wide. eg: ||| instead of ---
          pawnRotation = pawnRotation + vector(0, 90, 0)
        end
        pawn.setRotationSmooth(pawnRotation, false, false)
        
        -- Move the pawn
        local offsetFromPrevious = (spaceBetweenPawns + pawnWidth) * (k - 1)
        
        local x = offset.x + (pawnArrangementWidth / 2) - (pawnWidth / 2) - offsetFromPrevious
        local y = offset.y
        local z = offset.z
        
        pawn.setPositionSmooth(homeBoard.positionToWorld({x, y, z}), false, false)
      end
    end
  end
end

function ReturnHome.getAverageWidthOfPawns(pawns)
  local totalPawnWidth = 0
  for k, pawn in pairs(pawns) do
    if pawn then
      totalPawnWidth = totalPawnWidth + math.min(pawn.getBoundsNormalized().size.x, pawn.getBoundsNormalized().size.z)
    end
  end
  return totalPawnWidth / # pawns
end

function ReturnHome.getPawnArrangementWidth(pawns, pawnWidth, spaceBetween)
  return (# pawns * (pawnWidth + spaceBetween)) - spaceBetween
end

function ReturnHome.getPawnsOnBoard(homeBoard, pawnIds)
  if not homeBoard or not pawnIds then
    return {}
  end

  local bounds = homeBoard.getBounds()
  if not bounds or not bounds.size then
    return {}
  end

  local size = bounds.size
  size.x = size.x * 0.7
  size.z = size.z * 0.9

  local origin = homeBoard.getPosition()
  origin.y = origin.y + size.y

  local hits = Physics.cast({
    origin = origin,
    direction = {0, -1, 0},
    type = 3,
    size = size,
    max_distance = size.y * 2,
    debug = true
  })

  local hitObjectsByGuid = {}
  for _, hit in ipairs(hits) do
    local obj = hit.hit_object
    if obj then
      hitObjectsByGuid[obj.getGUID()] = obj
    end
  end

  local pawns = {}
  for _, pawnId in pairs(pawnIds) do
    local pawn = hitObjectsByGuid[pawnId]
    if pawn then
      table.insert(pawns, pawn)
    end
  end

  return pawns
end
