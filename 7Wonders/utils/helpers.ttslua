function AddCoins(color, amount, skip_message)
	if amount <= 0 then return end

	local amountToGive = amount

	if not skip_message then
		local coinText = (amount == 1) and " coin" or " coins"
		printToAll(Player[color].steam_name .. " gained " .. amount .. coinText, {r=0.5, g=0.5, b=0.5})
	end

	local coinSpawnPosition = Vector(PlayerInfo[color].WonderPos)
	coinSpawnPosition.y = 2
	coinSpawnPosition.x = coinSpawnPosition.x + math.random(-150, 150) / 100
	coinSpawnPosition.z = coinSpawnPosition.z + math.random(-100, 100) / 100

	if amount > 15 then
		CoinBags.Coin6.takeObject({
			position = coinSpawnPosition,
			rotation = PlayerInfo[color].ComponentRotation,
			smooth = false
		})

		amountToGive = amount - 6
		Wait.time(function() AddCoins(color, amountToGive, true) end, 0.1)
		return
	elseif amount <= 15 and amount > 6 then
		CoinBags.Coin3.takeObject({
			position = coinSpawnPosition,
			rotation = PlayerInfo[color].ComponentRotation,
			smooth = false
		})

		amountToGive = amount - 3
		Wait.time(function() AddCoins(color, amountToGive, true) end, 0.1)
		return
	elseif amount <= 6 then
		CoinBags.Coin1.takeObject({
			position = coinSpawnPosition,
			rotation = PlayerInfo[color].ComponentRotation,
			smooth = false
		})

		amountToGive = amount - 1
		Wait.time(function() AddCoins(color, amountToGive, true) end, 0.1)
		return
	end
end

function DiscardPlayerHands()
	for _, color in ipairs(getSeatedPlayers()) do
		local objects = Player[color].getHandObjects()
		for _, obj in ipairs(objects) do
			if obj.type == 'Card' then
				local discardZone
				-- Check memo to determine discard destination
				if obj.memo == "Ruins" or obj.memo == "Leader" then
					discardZone = DeckZones.AltDiscard
				else
					discardZone = DeckZones.Discard
				end

				obj.setPosition(discardZone.getPosition())
				obj.setRotation(discardZone.getRotation() + vector(0, 0, 180))
			end
		end
	end
end

function FindNextColor(Color, Direction)
  -- Use the correct seating order from Players array and only consider seated players
  for i, PlayerColor in ipairs(Players) do
    if PlayerColor == Color then
      local nextIndex = i
      repeat
        if Direction == "Left" then
          -- Move left around the table (next in array)
          nextIndex = nextIndex + 1
          if nextIndex > #Players then
            nextIndex = 1
          end
        else -- "Right"
          -- Move right around the table (previous in array)
          nextIndex = nextIndex - 1
          if nextIndex < 1 then
            nextIndex = #Players
          end
        end
        -- Keep looking until we find a seated player
      until Player[Players[nextIndex]].seated

      return Players[nextIndex]
    end
  end
end

function onChat(message, sender)
	-- Only allow host to use debug commands
	if not sender or not sender.host then
		return true
	end

	if message:lower() == ">end" then
		local playerName = "Unknown Player"
		if sender and sender.steam_name then
			playerName = sender.steam_name
		end
		broadcastToAll("Debug: Game ended by " .. playerName, {1, 0.5, 0})
		EndTheGame()
		return false
	elseif message:lower() == ">time" then
		local playerName = "Unknown Player"
		if sender and sender.steam_name then
			playerName = sender.steam_name
		end
		broadcastToAll("Debug: Timer results triggered by " .. playerName, {1, 0.5, 0})
		EndTheGame()
		return false
	elseif message:lower() == ">left" then
		local playerName = "Unknown Player"
		if sender and sender.steam_name then
			playerName = sender.steam_name
		end
		broadcastToAll("Debug: Forcing card pass LEFT by " .. playerName, {1, 0.5, 0})
		-- Rotate hands to the left first
		Wait.time(function()
			for _, PlayerInstance in ipairs(Player.getPlayers()) do
				local handObjects = PlayerInstance.getHandObjects()
				for _, Card in ipairs(handObjects) do
					RotateHands(Card, PlayerInstance.color, "Left")
				end
			end
		end, 0.1)
		-- Then force take cards from the right after delay
		Wait.time(function() ForceTakeCards("Right") end, 1)
		return false
	elseif message:lower() == ">right" then
		local playerName = "Unknown Player"
		if sender and sender.steam_name then
			playerName = sender.steam_name
		end
		broadcastToAll("Debug: Forcing card pass RIGHT by " .. playerName, {1, 0.5, 0})
		-- Rotate hands to the right first
		Wait.time(function()
			for _, PlayerInstance in ipairs(Player.getPlayers()) do
				local handObjects = PlayerInstance.getHandObjects()
				for _, Card in ipairs(handObjects) do
					RotateHands(Card, PlayerInstance.color, "Right")
				end
			end
		end, 0.1)
		-- Then force take cards from the left after delay
		Wait.time(function() ForceTakeCards("Left") end, 1)
		return false
	end

	return true
end

function disableAllTiles()
	for color, data in pairs(PlayerCardHolder) do
			if data.Tile then
				data.Tile.setLock(true)
				data.Tile.interactable = false
		end
	end
end

function ForceLoadAllAssets()
  -- Add any bags that should have their contents pre-loaded
  local AllBagsToLoad = {
    WonderBags.Base,
    WonderBags.Leaders,
    WonderBags.Cities,
    WonderBags.Armada,
    WonderBags.Edifice,
    WonderBags.Collection,
    WonderBags.Promo,
    WonderBags.Other,
    DockyardBag,
    FrontiersBag
  }

  for _, BagToLoad in ipairs(AllBagsToLoad) do
    if BagToLoad and BagToLoad.getObjects then
      for _, Board in ipairs(BagToLoad.getObjects()) do
        BagToLoad.takeObject({
          position = {68.00, -10, 19.00},
          smooth = false,
          callback_function = function(spawnedObject)
            --print(spawnedObject.getName())
            spawnedObject.setLock(true)

            -- Define recursive wait function
            local function checkAndReturn()
              if not spawnedObject.loading_custom then
                spawnedObject.setLock(false)
                BagToLoad.putObject(spawnedObject)
              else
                -- Still loading, check again in 2 seconds
                Wait.time(checkAndReturn, 2)
              end
            end

            -- Start the first check after 2 seconds
            Wait.time(checkAndReturn, 2)
          end
        })
      end
    else
      print("Warning: Bag not found or invalid - " .. tostring(BagToLoad))
    end
  end

  return 1
end

function LockSpawnedObject(object)
	object.setLock(true)
end

function ShowLoadingUI()
  -- Create loading panel XML
  local loadingXML = '<Panel id="LoadingPanel" color="#000000CC" padding="20 20 20 20" width="300" height="100" rectAlignment="MiddleCenter" offsetXY="0 0">'
  loadingXML = loadingXML .. '<Text text="LOADING..." fontSize="36" fontStyle="Bold" color="#FFFFFF" textAlignment="MiddleCenter" />'
  loadingXML = loadingXML .. '</Panel>'

  -- Get existing XML and append loading panel
  local existingXML = UI.getXml()
  if existingXML and existingXML ~= "" then
    UI.setXml(existingXML .. loadingXML)
  else
    UI.setXml(loadingXML)
  end
end

function HideLoadingUI()
  -- Hide the loading panel by setting active to false
  UI.setAttribute("LoadingPanel", "active", "false")
end

function printDeckZones()
	print("----- Printing All Deck Zones -----")

	-- Helper function to handle nested printing
	local function printTable(tbl, indent)
		indent = indent or 0
		local spacing = string.rep("  ", indent)

		for key, value in pairs(tbl) do
			if type(value) == "table" then
				print(spacing .. key .. ":")
				printTable(value, indent + 1)
			else
				if value ~= nil and value.getGUID then
					print(spacing .. key .. " = " .. value.getGUID())
				else
					print(spacing .. key .. " = " .. tostring(value))
				end
			end
		end
	end

	printTable(DeckZones)
	print("----- Finished Printing -----")
end

function TransferMoneyFromZones()
	-- Transfer all coins from money transfer zones to the appropriate adjacent players
	local seatedPlayers = getSeatedPlayers()

	for _, color in ipairs(seatedPlayers) do
		local leftZone = MoneyTransferZones[color].Left
		local rightZone = MoneyTransferZones[color].Right

		if leftZone then
			local leftTarget = FindNextColor(color, "Left")
			TransferCoinsFromZone(leftZone, leftTarget, color)
		end

		if rightZone then
			local rightTarget = FindNextColor(color, "Right")
			TransferCoinsFromZone(rightZone, rightTarget, color)
		end
	end
end

function TransferCoinsFromZone(zone, targetColor, senderColor)
	-- Transfer all coins from a specific zone to the target player's wonder area
	if not zone or not targetColor then return end

	local objectsInZone = zone.getObjects()
	local coinCount = 0

	for _, obj in ipairs(objectsInZone) do
		if obj.hasTag("Coin1") or obj.hasTag("Coin3") or obj.hasTag("Coin6") then
			coinCount = coinCount + GetCoinValue(obj)

			-- Move coin to target player's wonder area
			local targetPos = Vector(PlayerInfo[targetColor].WonderPos)
			targetPos.y = 2
			targetPos.x = targetPos.x + math.random(-150, 150) / 100
			targetPos.z = targetPos.z + math.random(-100, 100) / 100

			obj.setPosition(targetPos)
			obj.setRotation(PlayerInfo[targetColor].ComponentRotation)
			obj.highlightOn(senderColor, 5)
		end
	end

	if coinCount > 0 then
		local coinText = (coinCount == 1) and " coin" or " coins"
		printToAll(Player[senderColor].steam_name .. " sent " .. coinCount .. coinText .. " to " .. Player[targetColor].steam_name, senderColor)
	end
end

function GetCoinValue(obj)
	for _, tag in ipairs(obj.getTags()) do
		if string.match(tag, "^Coin%d+$") then
			return tonumber(string.match(tag, "%d+"))
		end
	end
	return 0 -- Default value if no coin tag found
end

function BlinkPlayerCardHolders()
	local seatedPlayers = getSeatedPlayers()
	for color, data in pairs(PlayerCardHolder) do
		local isSeated = false
		for _, seatedColor in ipairs(seatedPlayers) do
			if seatedColor == color then
				isSeated = true
				break
			end
		end
		if data.Tile and isSeated then
			data.Tile.setVar("isBlinking", true)
			local function doBlink()
				if data.Tile.getVar("isBlinking") then
					data.Tile.highlightOn(color, 1)
					Wait.time(function()
						if data.Tile.getVar("isBlinking") then
							doBlink()
						end
					end, 2)
				end
			end
			doBlink()
		end
	end
end
