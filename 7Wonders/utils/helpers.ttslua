function AddCoins(color, amount, skip_message)
	if amount <= 0 then return end

	local amountToGive = amount

	if not skip_message then
		local coinText = (amount == 1) and " coin" or " coins"
		printToAll(Player[color].steam_name .. " gained " .. amount .. coinText, {r=0.5, g=0.5, b=0.5})
	end

	local coinSpawnPosition = Vector(PlayerInfo[color].WonderPos)
	coinSpawnPosition.y = 2
	coinSpawnPosition.x = coinSpawnPosition.x + math.random(-150, 150) / 100
	coinSpawnPosition.z = coinSpawnPosition.z + math.random(-100, 100) / 100

	if amount > 15 then
		CoinBags.Coin6.takeObject({
			position = coinSpawnPosition,
			rotation = PlayerInfo[color].ComponentRotation,
			smooth = false
		})

		amountToGive = amount - 6
		Wait.time(function() AddCoins(color, amountToGive, true) end, 0.1)
		return
	elseif amount <= 15 and amount > 6 then
		CoinBags.Coin3.takeObject({
			position = coinSpawnPosition,
			rotation = PlayerInfo[color].ComponentRotation,
			smooth = false
		})

		amountToGive = amount - 3
		Wait.time(function() AddCoins(color, amountToGive, true) end, 0.1)
		return
	elseif amount <= 6 then
		CoinBags.Coin1.takeObject({
			position = coinSpawnPosition,
			rotation = PlayerInfo[color].ComponentRotation,
			smooth = false
		})

		amountToGive = amount - 1
		Wait.time(function() AddCoins(color, amountToGive, true) end, 0.1)
		return
	end
end

function DiscardPlayerHands()
	for _, color in ipairs(getSeatedPlayers()) do
		local objects = Player[color].getHandObjects()
		for _, obj in ipairs(objects) do
			if obj.type == 'Card' then
				local discardZone
				-- Check memo to determine discard destination
				if obj.memo == "Ruins" or obj.memo == "Leader" then
					discardZone = DeckZones.AltDiscard
				else
					discardZone = DeckZones.Discard
				end

				obj.setPosition(discardZone.getPosition())
				obj.setRotation(discardZone.getRotation() + vector(0, 0, 180))
			end
		end
	end
end

function SpendResources(color, cost)
    -- Resource deduction logic
end

function AddToTableau(color, card)
    -- Card placement logic
end

function CanBuildWonderStage(color)
    -- Wonder stage validation
end

function FindNextColor(Color, Direction)
  local tempAllPlayers = Player.getPlayers()
  for i, PlayerInstance in ipairs(tempAllPlayers) do
    if PlayerInstance.color == Color then
      if Direction == "Left" then
        -- Move left around the table (next in array)
        if i == #tempAllPlayers then
          return tempAllPlayers[1].color
        end
        return tempAllPlayers[i+1].color
    else -- "Right"
        -- Move right around the table (previous in array)
        if i == 1 then
          return tempAllPlayers[#tempAllPlayers].color
        end
        return tempAllPlayers[i-1].color
      end
    end
  end
end

function onChat(message, sender)
	-- Only allow host to use debug commands
	if not sender or not sender.host then
		return true
	end

	if message:lower() == "end" then
		local playerName = "Unknown Player"
		if sender and sender.steam_name then
			playerName = sender.steam_name
		end
		broadcastToAll("Debug: Game ended by " .. playerName, {1, 0.5, 0})
		EndTheGame()
		return false
	elseif message:lower() == "time" then
		local playerName = "Unknown Player"
		if sender and sender.steam_name then
			playerName = sender.steam_name
		end
		broadcastToAll("Debug: Timer results triggered by " .. playerName, {1, 0.5, 0})
		EndTheGame()
		return false
	end

	return true
end

function disableAllTiles()
	for color, data in pairs(PlayerCardHolder) do
			if data.Tile then
				data.Tile.setLock(true)
				data.Tile.interactable = false
		end
	end
end

function ForceLoadAllAssets()
  -- Add any bags that should have their contents pre-loaded
  local AllBagsToLoad = {
		WonderBags.Base,
		WonderBags.Leaders,
		WonderBags.Cities,
		WonderBags.Armada,
		WonderBags.Edifice,
		WonderBags.Collection,
		WonderBags.Promo,
		WonderBags.Other,
		DockyardBag,
		FrontiersBag
  }

  for _, BagToLoad in ipairs(AllBagsToLoad) do
    if BagToLoad and BagToLoad.getObjects then
			--print(BagToLoad.getName())
      for _, Board in ipairs(BagToLoad.getObjects()) do
        BagToLoad.takeObject({
          position = {68.00, -10, 19.00},
          smooth = false,
          callback_function = function(spawnedObject)
						--print(spawnedObject.getName())
            spawnedObject.setLock(true)

            -- Define recursive wait function
            local function checkAndReturn()
                if not spawnedObject.loading_custom then
                    spawnedObject.setLock(false)
                    BagToLoad.putObject(spawnedObject)
                else
                    -- Still loading, check again in 2 seconds
                    Wait.time(checkAndReturn, 2)
                end
            end

            -- Start the first check after 2 seconds
            Wait.time(checkAndReturn, 2)
          end
        })
      end
    else
        print("Warning: Bag not found or invalid - " .. tostring(BagToLoad))
    end
  end

  return 1
end

function LockSpawnedObject(object)
	object.setLock(true)
end

function printDeckZones()
	print("----- Printing All Deck Zones -----")

	-- Helper function to handle nested printing
	local function printTable(tbl, indent)
		indent = indent or 0
		local spacing = string.rep("  ", indent)

		for key, value in pairs(tbl) do
			if type(value) == "table" then
				print(spacing .. key .. ":")
				printTable(value, indent + 1)
			else
				if value ~= nil and value.getGUID then
					print(spacing .. key .. " = " .. value.getGUID())
				else
					print(spacing .. key .. " = " .. tostring(value))
				end
			end
		end
	end

	printTable(DeckZones)
	print("----- Finished Printing -----")
end

function TransferMoneyFromZones()
	-- Transfer all coins from money transfer zones to the appropriate adjacent players
	local seatedPlayers = getSeatedPlayers()

	for _, color in ipairs(seatedPlayers) do
		local leftZone = MoneyTransferZones[color].Left
		local rightZone = MoneyTransferZones[color].Right

		if leftZone then
			local leftTarget = FindNextColor(color, "Left")
			TransferCoinsFromZone(leftZone, leftTarget, color)
		end

		if rightZone then
			local rightTarget = FindNextColor(color, "Right")
			TransferCoinsFromZone(rightZone, rightTarget, color)
		end
	end
end

function TransferCoinsFromZone(zone, targetColor, senderColor)
	-- Transfer all coins from a specific zone to the target player's wonder area
	if not zone or not targetColor then return end

	local objectsInZone = zone.getObjects()
	local coinCount = 0

	for _, obj in ipairs(objectsInZone) do
		if obj.hasTag("Coin1") or obj.hasTag("Coin3") or obj.hasTag("Coin6") then
			coinCount = coinCount + GetCoinValue(obj)

			-- Move coin to target player's wonder area
			local targetPos = Vector(PlayerInfo[targetColor].WonderPos)
			targetPos.y = 2
			targetPos.x = targetPos.x + math.random(-150, 150) / 100
			targetPos.z = targetPos.z + math.random(-100, 100) / 100

			obj.setPosition(targetPos)
			obj.setRotation(PlayerInfo[targetColor].ComponentRotation)
			obj.highlightOn(senderColor, 5)
		end
	end

	if coinCount > 0 then
		local coinText = (coinCount == 1) and " coin" or " coins"
		printToAll(Player[senderColor].steam_name .. " sent " .. coinCount .. coinText .. " to " .. Player[targetColor].steam_name, senderColor)
	end
end

function GetCoinValue(obj)
	for _, tag in ipairs(obj.getTags()) do
		if string.match(tag, "^Coin%d+$") then
			return tonumber(string.match(tag, "%d+"))
		end
	end
	return 0 -- Default value if no coin tag found
end

function BlinkPlayerCardHolders()
	local seatedPlayers = getSeatedPlayers()
	for color, data in pairs(PlayerCardHolder) do
		local isSeated = false
		for _, seatedColor in ipairs(seatedPlayers) do
			if seatedColor == color then
				isSeated = true
				break
			end
		end
		if data.Tile and isSeated then
			data.Tile.setVar("isBlinking", true)
			local function doBlink()
				if data.Tile.getVar("isBlinking") then
					data.Tile.highlightOn(color, 1)
					Wait.time(function()
						if data.Tile.getVar("isBlinking") then
							doBlink()
						end
					end, 2)
				end
			end
			doBlink()
		end
	end
end
